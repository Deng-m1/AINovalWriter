# **后台任务系统 \- 后端任务分解 (AINovalServer) (V1.5 \- MQ+事件深度融合版)**

Version: 1.5 (深度融合版)  
Date: 2025-04-25  
Based on Architecture: 后台任务系统：结合 Spring 特性 (MQ \+ Application Events) (Version 1.2) & 后台任务系统后端任务分解 (V1.4 详细设计)  
Supersedes: 后台任务系统后端任务分解 (V1.5 \- MQ 与 Spring 事件版) & (V1.4 \- 任务多样性支持)  
Changes:

* **深度融合:** 将 V1.4 版本中的详细设计思考、业务场景考量、任务多样性应对策略，与基于 MQ 和 Spring 事件的新架构 (V1.5 初稿) 进行全面整合。  
* **详细阐述:** 对核心框架、持久化、MQ 交互、消费者逻辑、事件处理、具体任务实现、高可用性等方面进行了更深入的解释和细化。  
* **强调设计原理:** 解释了采用泛型、DTO、事件机制等设计选择背后的原因和优势。  
* **细化业务任务:** 详细说明了 V1.4 中提到的具体任务（单/批量生成摘要/场景）在 MQ+事件架构下的实现要点。  
* **恢复关键细节:** 重新引入了 V1.4 中关于虚拟线程优势、并发控制目的、任务恢复重要性等的详细讨论，并将其置于新架构的背景下。  
* **结构优化:** 调整了章节和任务点，使其逻辑更连贯，内容更充实。

## **1\. 核心框架、模型与 DTO 定义 (Foundation, Models & DTOs \- 深度融合)**

* **\[Task-Core-01\] 定义任务状态枚举 (TaskStatus.java):**  
  * 位置: com.ainovel.server.task.model  
  * 内容: QUEUED, RUNNING, COMPLETED, FAILED, CANCELLED, RETRYING, DEAD\_LETTER, COMPLETED\_WITH\_ERRORS (可选)。状态定义清晰是任务生命周期管理的基础。RETRYING 和 DEAD\_LETTER 对于区分暂时失败和最终失败至关重要。COMPLETED\_WITH\_ERRORS 用于精细化表示批量任务的部分成功。  
  * 复杂度: 低  
* **\[Task-Core-02\] 定义后台任务数据模型 (BackgroundTask.java):** (保留 V1.4 字段，强调用途)  
  * 位置: com.ainovel.server.task.model  
  * 注解: @Document(collection \= "background\_tasks")。MongoDB 适用于存储结构灵活的任务数据。  
  * 字段:  
    * id, userId, taskType, status: 核心标识与状态。  
    * parameters (Object): **(关键)** 存储序列化后的具体参数 DTO。这是支持任务多样性的核心，避免了 V1.1 中 Map 的模糊性。**必须**为每种 taskType 定义 DTO。  
    * progress (Object): 存储序列化后的具体进度 DTO。结构需灵活，能表示简单计数或复杂子任务状态。  
    * result (Object): 存储序列化后的具体结果 DTO。  
    * errorInfo (Map\<String, Object\>): 记录最后或关键错误信息（消息、堆栈、时间戳、重试次数等）。  
    * createdAt, updatedAt: 标准时间戳。  
    * retryCount: 当前重试次数，用于重试策略。  
    * lastAttemptTimestamp: 上次尝试执行时间，用于监控僵尸任务。  
    * nextAttemptTimestamp: **(仅供参考)** 在 MQ 架构下，实际调度由 MQ 的延迟/重试机制处理，此字段主要用于数据库记录和可能的手动查询，**不直接用于调度**。  
    * executionNodeId: 多实例部署时标记处理节点，用于调试和恢复判断。  
    * parentTaskId: 支持子任务模型，建立任务依赖关系。  
    * subTaskStatusSummary: 父任务快速了解子任务整体状态的摘要。  
  * **序列化:** 必须配置好 Jackson/Mongo Converter，确保 Object 字段能正确映射到具体的 DTO 类。考虑使用 @JsonTypeInfo 或类似机制处理多态 DTO（如果需要）。  
  * 复杂度: 中-高  
* **\[Task-Core-03\] 定义任务执行器接口 (BackgroundTaskExecutable\<P, R\>):** (保留 V1.4 泛型和钩子)  
  * 位置: com.ainovel.server.task  
  * 泛型 \<P, R\>: 强制实现者明确输入输出类型，是类型安全的核心。  
  * 方法:  
    * R execute(TaskContext\<P\> context): 核心执行逻辑。  
    * String getTaskType(): 返回唯一类型标识。  
    * Class\<P\> getParameterType(): **(关键)** 运行时获取参数类型，用于反序列化。  
    * Class\<R\> getResultType(): **(关键)** 运行时获取结果类型，用于可能的反序列化或类型检查。  
    * 可选方法: reportProgress, isCancellable, cancel，以及 onQueued, onRunning, onCompleted, onFailed, onCancelled 等生命周期钩子，提供更强的灵活性和扩展点。  
  * 复杂度: 高  
* **\[Task-Core-04\] 定义任务上下文接口 (TaskContext\<P\>):** (保留 V1.4 泛型和方法)  
  * 位置: com.ainovel.server.task  
  * 泛型 \<P\>: 提供类型安全的参数访问 getParameters()。  
  * 方法: getTaskId, getUserId, getParameters, getParentTaskId, updateProgress (触发内部事件), logInfo, logError, submitSubTask (调用生产者发送子任务消息)。提供任务执行所需的一切上下文和回调。  
  * 复杂度: 中  
* **\[Task-Core-DTO-01\] 定义所有任务的 Parameters/Result/Progress DTO:** (**强制要求，细化重要性**)  
  * 位置: com.ainovel.server.task.dto.\<TaskType\>  
  * **重要性:** 这是应对任务多样性、保证代码质量的**基石**。相比 V1.1 的 Map，强类型 DTO 能在编译期发现错误，提高代码可读性、可维护性，并使序列化/反序列化更可靠。**必须**为每一种 taskType 定义清晰的 DTO。  
  * 实践: 使用 Record 或 Lombok @Data。保持 DTO 的数据传输职责，避免包含过多业务逻辑。  
  * 复杂度: 低 (单个 DTO) / 中 (整体数量)  
* **\[Task-Core-Event-01\] 定义 Spring Application Event 类:** (同 V1.5 初稿)  
  * 位置: com.ainovel.server.task.event.internal  
  * 定义: TaskSubmittedEvent, TaskStartedEvent, TaskProgressApplicationEvent, TaskCompletedApplicationEvent, TaskFailedApplicationEvent, TaskRetryingApplicationEvent 等。携带必要上下文。用于应用内部解耦。  
  * 复杂度: 中  
* **\[Task-Core-Event-02\] 定义外部事件 DTO (TaskExternalEvent.java):** (同 V1.5 初稿)  
  * 位置: com.ainovel.server.task.event.external  
  * 用于发送到外部 MQ 事件总线，可定制化。  
  * 复杂度: 低

## **2\. 持久化层 (Persistence Layer \- 融合 V1.4 思考)**

* **\[Task-Persist-01\] 创建 MongoDB Repository (BackgroundTaskRepository.java):** (细化职责)  
  * 位置: com.ainovel.server.repository  
  * 职责: 提供底层的数据库 CRUD 操作。在新架构下，**不再负责**查找待重试或僵尸任务（这些由 MQ 和消费者逻辑处理）。主要提供按 ID、用户、状态、父任务 ID 查询的能力。  
  * **原子更新:** 强调需要提供支持原子更新的方法，例如使用 MongoDB 的 findAndModify 或 Spring Data 的 @Version 乐观锁来安全地更新任务状态、进度、结果，防止并发冲突（例如，消费者更新状态与事件监听器更新状态之间的冲突）。  
  * 索引: (同 V1.4) 重点索引查询字段 userId, status, taskType, parentTaskId。  
  * 复杂度: 中  
* **\[Task-Persist-02\] 实现状态数据库服务 (TaskStateService.java):** (细化职责)  
  * 位置: com.ainovel.server.task.service  
  * 职责: **封装 Repository**，提供面向业务场景的、**保证原子性**的状态管理接口。例如：  
    * BackgroundTask createTask(String userId, String taskType, P params): 创建任务记录。  
    * boolean tryUpdateStatus(String taskId, TaskStatus expectedStatus, TaskStatus newStatus): 原子地更新状态（如果当前状态匹配）。  
    * void updateProgress(String taskId, Object progressData): 更新进度（可能需要乐观锁）。  
    * void completeTask(String taskId, R result): 原子地更新状态为 COMPLETED 并保存结果。  
    * void failTask(String taskId, Map\<String, Object\> errorInfo, boolean isDeadLetter): 原子地更新状态为 FAILED/DEAD\_LETTER 并保存错误。  
  * 注入: BackgroundTaskRepository, ObjectMapper (用于序列化 P/R/Progress)。  
  * **重要性:** 该服务是保证数据库状态一致性的关键，隔离了底层 Repository 的复杂性。  
  * 复杂度: 中

## **3\. 消息队列基础设施与配置 (MQ Infrastructure & Configuration \- 融合 V1.4 思考)**

* **\[Task-MQ-Infra-01\] 配置 RabbitMQ 拓扑结构:** (细化说明)  
  * 方式: 使用 @Configuration 和 RabbitAdmin。代码化配置优于手动配置，便于版本控制和环境一致性。  
  * 声明元素: (同 V1.5 初稿) Exchanges (tasks, retry, requeue, dlx, events), Queues (tasks, waits, dlq, event subs), Bindings。  
  * **关键配置:**  
    * tasks.queue: 必须配置 x-dead-letter-exchange 到 tasks.retry.exchange。  
    * tasks.wait\_\*.queue: 必须配置 x-message-ttl 和 x-dead-letter-exchange 到 tasks.requeue.exchange。  
    * 所有元素 durable=true。  
  * **设计原理:** 利用 DLX 和 TTL 巧妙地实现了延迟重试，无需应用层维护定时器。  
  * 复杂度: 中  
* **\[Task-MQ-Infra-02\] 配置 RabbitTemplate:** (细化说明)  
  * **MessageConverter:** 配置 Jackson2JsonMessageConverter 是处理 DTO 序列化的标准做法。确保 ObjectMapper 配置正确（例如处理日期、多态等）。  
  * **Publisher Confirms & Returns:** **必须启用并配置回调处理逻辑**。在 TaskMessageProducer 中实现 ConfirmCallback 和 ReturnsCallback，记录发送失败或无法路由的消息，并根据业务决定是否重试发送或标记任务创建失败。这是保证消息至少发送一次的关键。  
  * **持久化:** deliveryMode=PERSISTENT。  
  * 复杂度: 中  
* **\[Task-MQ-Infra-03\] 配置 RabbitListener Container Factory:** (细化说明)  
  * **Manual Ack:** acknowledgeMode \= AcknowledgeMode.MANUAL 是必须的，由业务逻辑控制消息确认。  
  * **Concurrency:** concurrency (最小消费者数) 和 maxConcurrency (最大消费者数) 控制了并行处理能力。需要根据预期的任务负载和下游服务能力进行调整。  
  * **Prefetch Count:** 合理设置 prefetchCount (例如 1 或稍大一点的值) 可以防止单个消费者过载或持有过多未处理消息，有助于负载均衡和快速失败检测。  
  * **Error Handler:** 配置自定义 ErrorHandler 可以统一处理监听器方法中未捕获的异常，例如记录日志、发送告警，但**不应**在这里做 ACK/NACK 决策（应在监听器方法内部处理）。  
  * 复杂度: 中

## **4\. 任务生产者组件 (Task Producer Components \- 融合 V1.4 思考)**

* **\[Task-MQ-Prod-01\] 实现任务消息生产者服务 (TaskMessageProducer.java):** (细化可靠性)  
  * 注入: RabbitTemplate (已配置好确认和返回回调)。  
  * 方法: void sendTask(...)。  
  * 逻辑:  
    * 序列化 DTO。  
    * 构造 Message，**设置 messageId** (用于日志追踪和可能的幂等检查)，设置 correlationId (用于链路追踪)。  
    * 调用 rabbitTemplate.convertAndSend。  
    * **处理回调:** 在 ConfirmCallback 中处理 ACK/NACK（记录日志，可能重试发送），在 ReturnsCallback 中处理无法路由的情况（记录错误，可能标记任务失败）。  
  * 复杂度: 中  
* **\[Task-Submit-01\] 实现任务提交服务 (TaskSubmissionService.java):** (细化事务和事件)  
  * 注入: TaskStateService, ApplicationEventPublisher。  
  * 方法: String submitTask(...)。  
  * **推荐逻辑 (带内部事件):**  
    1. @Transactional (本地数据库事务)。  
    2. 调用 TaskStateService.createTask(...) 创建 DB 记录 (QUEUED)。  
    3. applicationEventPublisher.publishEvent(new TaskSubmittedEvent(...))。  
    4. 事务提交。  
  * **替代逻辑 (直接发 MQ):**  
    1. 调用 TaskStateService.createTask(...)。  
    2. 调用 TaskMessageProducer.sendTask(...)。需要处理发送失败的情况（例如，回滚 DB 状态或标记为失败）。  
  * **权衡:** 方案一更符合事件驱动，解耦更好，但依赖监听器发送 MQ。方案二更直接，但耦合了 DB 和 MQ 操作。  
  * 复杂度: 中  
* **\[Task-Submit-Listener-01\] 实现 TaskSubmittedEvent 监听器 (可选):** (细化职责)  
  * 职责: 监听内部 TaskSubmittedEvent，调用 TaskMessageProducer 将任务实际发送到 MQ。这是将任务持久化与 MQ 发送解耦的关键。  
  * 错误处理: 需要处理 TaskMessageProducer 发送失败的情况（记录日志，可能发布一个 TaskCreationFailedEvent）。  
  * 复杂度: 低

## **5\. 任务消费者与执行器组件 (Task Consumer & Executor Components \- 融合 V1.4 思考)**

* **\[Task-Consume-01\] 实现主任务消费者 (TaskConsumer.java):** (细化错误处理和状态)  
  * 方法: @RabbitListener(...) public void handleTaskMessage(...)。  
  * 注入: TaskExecutorService, ApplicationEventPublisher, ObjectMapper, RabbitTemplate (用于手动重试/死信)。  
  * **核心逻辑细化:**  
    1. 获取 deliveryTag, 解析消息。  
    2. **幂等性检查 (可选但推荐):** 检查 taskId 是否已被处理（查询 DB 状态）。如果已完成/失败，则直接 ACK 并返回。  
    3. 查找执行器，反序列化参数 P。**处理反序列化失败** (通常 NACK 并可能发往 DLQ)。  
    4. 发布 TaskStartedEvent (通知内部系统任务开始)。  
    5. **调用 TaskExecutorService.executeTask:**  
       * executeTask 内部调用 executable.execute()。  
       * executeTask 负责捕获 executable 抛出的异常，并**分类**为可重试或不可重试。  
    6. **根据 executeTask 返回的结果或异常类型进行处理:**  
       * **成功:** 发布 TaskCompletedEvent，ACK。  
       * **可重试失败:** 判断重试次数，发布 TaskRetryingEvent，**NACK 并路由到重试**。  
       * **不可重试失败:** 发布 TaskFailedEvent (标记非死信)，NACK (可能路由到 DLQ)。  
       * **达到重试上限:** 发布 TaskFailedEvent (标记死信)，NACK (路由到 DLQ)。  
    7. **捕获意外异常:** 记录严重错误，发布 TaskFailedEvent (标记死信)，NACK。  
    8. **Finally:** 确保 channel 操作（ACK/NACK）在所有路径都被执行。  
  * **虚拟线程:** 消费者逻辑本身（反序列化、调用服务、发布事件、ACK/NACK）通常很快。核心的 executable.execute() 如果涉及 IO，应确保其内部逻辑（或其调用的服务）能有效利用虚拟线程（例如，使用支持虚拟线程的 HTTP 客户端、数据库驱动，或者将阻塞操作包装在 CompletableFuture.supplyAsync(..., virtualThreadExecutor) 中）。Spring AMQP 的 @RabbitListener 默认在平台线程池上运行，如果需要将整个消费者逻辑（包括 IO 密集型的 execute）放到虚拟线程上，需要自定义 TaskExecutor 并配置给 ListenerContainerFactory。  
  * 复杂度: 高  
* **\[Task-Consume-Retry-01\] 实现重试路由/发布逻辑:** (细化策略)  
  * **关键:** 消费者 NACK 时，如何确保消息能进入**正确**的等待队列？  
    * **策略1 (基于 Header \+ Routing):** 消费者在 NACK 前，计算下次延迟对应的路由键 (e.g., "retry.5m")，并将此路由键设置到消息的一个 Header (e.g., "x-retry-routing-key")。配置 tasks.retry.exchange 为 Headers Exchange，根据这个 Header 来路由消息到不同的等待队列。  
    * **策略2 (使用 Delayed Message Plugin):** 消费者计算延迟毫秒数，设置到消息的 x-delay Header，然后 ACK 原消息，并将带有 x-delay 头的新消息重新 **Publish** 回 tasks.exchange。这是目前更推荐的方式，因为它不需要管理多个等待队列。  
  * **重试次数:** 必须在消息属性 (e.g., x-retry-count) 中可靠地传递和递增。  
  * 复杂度: 中-高  
* **\[Task-Exec-Svc-01\] 实现任务执行器服务 (TaskExecutorService.java):** (细化错误分类)  
  * 注入: List\<BackgroundTaskExecutable\<?, ?\>\>。  
  * executeTask 方法:  
    * 调用 executable.execute()。  
    * **捕获异常:** catch (Exception e)。  
    * **异常分类:** 根据异常类型 (e.g., instanceof IOException, instanceof BusinessRuleException, instanceof ApiRateLimitException) 或错误码，判断是可重试还是不可重试，并向上抛出包装后的异常（或返回包含错误信息的 Result 对象）给 TaskConsumer。  
  * 复杂度: 中  
* **\[Task-Exec-Impl-01..N\] 实现具体的 BackgroundTaskExecutable\<P, R\>:** (细化业务结合)  
  * **GenerateSummaryTask / GenerateSceneTask:**  
    * P: 包含 sceneId 或 summary, aiConfig 等。  
    * R: 包含生成的 summary 或 sceneContent。  
    * execute: 调用 AIService。处理 AIService 可能抛出的特定异常（如 API key 无效 \- 不可重试；超时/5xx \- 可重试；限流 \- 可重试）。  
  * **BatchGenerateSummaryTask / BatchGenerateSceneTask:**  
    * P: 包含 novelId 或 sceneIds, aiConfig。  
    * R: 包含成功/失败列表，或指向存储结果的位置。  
    * Progress DTO: 包含 total, processed, success, failed 计数。  
    * **实现方式 (MQ 架构下):**  
      * **方式 A (单任务循环):** 在 execute 中循环处理每个子项。每次调用 AIService 前检查限流。通过 context.updateProgress 汇报进度。如果某个子项失败，根据策略（记录失败并继续，或直接失败整个任务）处理。适合子项数量不多或需要严格顺序的场景。  
      * **方式 B (父子任务模型 \- 推荐):** 父任务 execute 负责创建并提交**多个**独立的子任务消息（每个子任务处理一个场景/摘要）到 MQ，通过 context.submitSubTask。父任务本身可能很快完成（状态变为 RUNNING 或 PROCESSING\_SUBTASKS）。父任务的状态最终由监听子任务事件的 StateAggregatorService 来聚合更新（例如，当所有子任务都完成或失败时，更新父任务状态为 COMPLETED, FAILED, 或 COMPLETED\_WITH\_ERRORS）。这种方式充分利用了 MQ 的并行处理和解耦能力。  
  * 复杂度: 中-高

## **6\. 事件处理组件 (Event Handling Components \- 细化职责)**

* **\[Task-Event-State-01\] 实现状态聚合服务 (StateAggregatorService.java):** (核心状态同步)  
  * 职责: **保证数据库状态与任务实际执行状态的最终一致性**。它是连接异步事件和持久化状态的关键。  
  * 监听所有内部任务事件。  
  * **幂等性:** 事件处理需要幂等，防止重复处理同一个事件导致状态错误（例如，使用事件 ID 或检查任务当前状态）。  
  * **原子性:** 调用 TaskStateService 的原子更新方法。  
  * **子任务聚合:** 如果采用子任务模型，需要监听子任务事件，并在所有子任务完成后更新父任务状态。  
  * **异步处理:** 使用 @Async 避免阻塞事件发布者（消费者线程）。  
  * 复杂度: 中-高  
* **\[Task-Event-Bridge-01\] 实现外部事件桥接器 (ExternalEventBridge.java):** (内外边界)  
  * 职责: 将**需要通知外部系统**的内部 Spring 事件，转换为消息发送到外部 MQ 事件总线。  
  * 选择性桥接: 只监听并转发真正需要外部感知的事件（如 COMPLETED, FAILED, 重要 PROGRESS）。  
  * 格式转换: 可能需要将内部事件 DTO 转换为标准化的外部事件 DTO。  
  * 复杂度: 中  
* **\[Task-Event-Pub-Ext-01\] 实现外部事件发布器 (TaskEventPublisher.java):** (简单封装)  
  * 封装 RabbitTemplate 发送到 tasks.events.exchange 的逻辑。  
  * 复杂度: 低  
* **\[Task-Event-Sub-Ext-01..N\] 实现外部事件订阅者:** (按需实现)  
  * 复杂度: 中

## **7\. 其他支持组件与配置 (Supporting Components & Configuration \- 细化)**

* **\[Task-Support-RateLimit-01\] 实现限流服务 (RateLimiterService.java):** (同 V1.4)  
* **\[Task-Support-Config-01\] 添加相关配置到 application.yml:** (细化 MQ 相关)  
  * spring.rabbitmq.\*: 连接信息, Publisher Confirms/Returns 开关。  
  * spring.amqp.listener.simple.\*: 消费者并发、预取、确认模式、重试（Spring AMQP 自带的简单重试，通常不用，我们用 MQ 拓扑实现）。  
  * task.retry.maxAttempts: 应用层判断最大次数。  
  * task.ratelimiter.\*: (同 V1.4)。  
  * 复杂度: 低  
* **\[Task-Support-Log-01\] 配置详细日志记录:** (强调 MQ 和事件)  
  * **MDC:** 必须包含 taskId, userId, taskType, traceId。  
  * **关键点:** 记录消息发送 (含 ID)、接收 (含 ID)、ACK/NACK (含 ID)、重试路由、死信进入、事件发布、事件处理。  
  * 复杂度: 低  
* **\[Task-Support-Monitor-01\] 添加监控指标:** (细化 MQ 指标)  
  * **MQ 指标 (通过 Actuator / Micrometer):**  
    * rabbitmq.messages.published.total, rabbitmq.messages.delivered.total, rabbitmq.messages.acked.total, rabbitmq.messages.nacked.total (按队列/交换机区分)。  
    * rabbitmq.queue.messages, rabbitmq.queue.messages.ready, rabbitmq.queue.messages.unacked (监控队列深度)。  
    * spring.integration.channel.queue.size (如果使用 Spring Integration)。  
  * **应用指标:** (同 V1.4) 任务计数、时长、重试、限流、事件处理计数/时长。  
  * 复杂度: 中  
* **\[Task-Support-Recovery-01\] 实现死信处理机制/API:** (同 V1.4)  
* **\[Task-Support-Shutdown-01\] 实现优雅停机:** (细化 MQ Listener 关闭)  
  * 监听 ContextClosedEvent。  
  * 调用 rabbitListenerEndpointRegistry.stop() 停止所有 @RabbitListener 接收新消息。  
  * **等待处理完成:** 需要一种机制等待当前正在处理的消息完成 ACK/NACK。可以结合 SimpleMessageListenerContainer 的 shutdownTimeout 或自定义逻辑。  
  * 关闭自定义的 ExecutorService (如果 Task Executable 内部使用了)。  
  * 复杂度: 中

## **8\. 集成与测试 (Integration & Testing \- 细化 MQ 测试)**

* **单元测试:** (同 V1.4)  
* **集成测试:**  
  * **MQ 交互:** 验证消息能否正确发送到指定交换机/队列，消费者能否接收，ACK/NACK 是否按预期工作。  
  * **重试流程 (关键):** 模拟消费者 NACK，验证消息是否根据 DLX+TTL 或 Delayed Plugin 正确地延迟并重新入队，x-retry-count 是否递增。  
  * **死信流程 (关键):** 模拟达到最大重试次数，验证消费者是否正确 NACK，消息是否最终进入 DLQ。  
  * **事件流程:** 验证 Spring Event 是否触发，内部 Listener 是否执行，外部 MQ Event 是否发送和被接收。  
  * **端到端 (带依赖):** 使用 Testcontainers 启动 RabbitMQ 和 MongoDB，测试完整流程。  
* 复杂度: 高

## **9\. 文档 (Documentation \- 细化)**

* **API 文档:** (同 V1.4)  
* **架构文档:** 更新本文档 V1.5，**必须包含清晰的 RabbitMQ 拓扑图和说明**，解释重试和死信机制，描述 Spring 事件和 MQ 事件的分工。  
* **开发者指南:** **必须提供**添加新任务的步骤：1) 定义 P/R/Progress DTO；2) 实现 BackgroundTaskExecutable\<P,R\>；3) (如果需要) 添加特定配置；4) 编写单元/集成测试。说明如何配置和运行本地 MQ/DB 进行开发测试。  
* 复杂度: 中

**依赖关系与顺序建议:** (同 V1.5 初稿，强调 DTO 优先)

1. **核心框架 & 模型 & DTO:** (优先定义 DTO)  
2. **持久化层:** (Repository \+ TaskStateService)  
3. **MQ 基础设施配置:** (声明拓扑，配置 Template/Factory)  
4. **任务生产者组件:**  
5. **核心消费者逻辑:** (骨架，ACK/NACK 框架)  
6. **任务执行器服务与实现:**  
7. **事件发布与监听 (Spring Events):**  
8. **重试与死信逻辑:** (完善 Consumer)  
9. **事件桥接与外部事件 (MQ Events):**  
10. **其他支持组件:**  
11. **测试与文档:** (贯穿)

这个 V1.5 深度融合版本，旨在提供一个既符合现代分布式系统设计原则（MQ、事件驱动），又能充分利用 Spring 生态便利性，并且通过良好的抽象设计有效支持 AINovalWriter 后台任务多样性和复杂性的详细任务分解方案。