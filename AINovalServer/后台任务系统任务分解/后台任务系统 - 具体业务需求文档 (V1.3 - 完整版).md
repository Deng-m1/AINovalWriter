# **后台任务系统 \- 具体业务需求文档 (V1.3 \- 完整版)**

Version: 1.3  
Date: 2025-04-25  
Based on: V1.2 (深度扩展版)  
Changes:

* **修正服务调用:** 将文档中所有对 AIService 的直接调用修正为通过 NovelAIService 接口进行，以符合项目架构和代码实现。  
* **明确接口依赖:** 更新了“复用性分析”和“任务分解关联”部分，以反映对 NovelAIService 及其相关方法的依赖。  
* **细化续写流程 (REQ-TASK-002):** 明确了“逐章生成摘要-\>生成内容”的循环模式，并强调使用子任务实现。  
* **内容完整性:** 移除了“(保持 V1.2 不变)”的占位符，填充了完整的章节内容。

**目标:** 定义 AINovalWriter 后台任务系统需要实现的具体业务功能需求，明确输入、输出、处理流程、与现有功能的复用关系、并发处理策略，并指导后续的任务实现。

**核心架构:** 基于 V1.6 文档定义的 RabbitMQ \+ Spring AMQP \+ Spring Application Events \+ MongoDB 架构。

## **1\. 需求概述 (深度阐述)**

AINovalWriter 旨在利用 AI 提升小说创作效率和质量。随着功能的深入，一些计算密集型或耗时较长的操作（如批量处理、复杂 AI 推理）需要通过后台任务系统异步执行，以避免阻塞用户界面，提供流畅的写作体验。本期后台任务系统聚焦于自动化和智能化的内容生成辅助，核心业务场景包括：

1. **批量生成场景摘要 (REQ-TASK-001):**  
   * **背景:** 用户在完成或导入大量章节后，为每个场景手动添加摘要是一项繁重且耗时的工作。  
   * **价值:** 自动化此过程能极大节省用户时间，快速生成内容概览，便于后续内容管理和 AI 功能（如 RAG）的应用。  
   * **核心挑战:** 处理大量场景的并发 AI 调用、管理任务进度，以及应对用户在任务执行期间可能对场景内容进行的并发修改。  
   * **本期重点:** 实现基于指定章节范围的批量摘要生成，并采用乐观锁（版本号）机制处理并发修改冲突。  
2. **续写小说章节内容 (REQ-TASK-002):**  
   * **背景:** 作者在创作过程中可能遇到瓶颈，或希望快速拓展故事情节。  
   * **价值:** 提供一种智能化的续写能力，系统能基于现有内容和设定，自动生成后续章节的摘要和详细内容，为作者提供灵感或草稿，加速创作进程。  
   * **核心挑战:** 理解并利用恰当的上下文信息进行连贯续写，协调摘要生成和内容生成两个阶段的任务，管理复杂的工作流状态。  
   * **本期重点:** 实现指定数量章节的“摘要生成 \+ 内容生成”两阶段续写流程，采用子任务模型进行协调。  
3. **续写小说章节摘要 (REQ-TASK-003):**  
   * **背景:** 作者可能只需要快速规划后续章节的故事梗概，暂时不需要详细内容。  
   * **价值:** 提供一个轻量级的续写选项，快速生成情节大纲，便于作者进行结构调整和思路梳理。  
   * **核心挑战:** 与 REQ-TASK-002 类似，需要有效利用上下文生成连贯的摘要。  
   * **本期重点:** 实现指定数量章节的摘要续写功能，作为独立任务，同时也是 REQ-TASK-002 的第一阶段。

## **2\. 功能需求详解 (深度阐述)**

### **2.1 自动为指定章节范围生成场景摘要 (Batch Generate Scene Summaries)**

* **需求编号:** REQ-TASK-001  
* **关联任务分解:** Task 8.3 (BatchGenerateSummaryTaskExecutable) 作为父任务，Task 8.1 (GenerateSummaryTaskExecutable) 作为子任务。  
* **目标:** 高效、可靠地为用户选定范围内的场景生成摘要，并优雅处理并发修改。  
* **用户故事:** 作为一名作者，我希望能选择小说的某几章，让系统自动为这些章节下的所有场景生成摘要，即使我在后台任务运行时修改了某些场景，系统也能妥善处理，最终告诉我哪些成功了，哪些因为修改或错误而失败/跳过。  
* **触发方式:**  
  * **前端交互:** 提供清晰的界面允许用户选择：  
    * 目标小说。  
    * 起始章节和结束章节（通过下拉列表或树状结构选择）。  
    * 用于生成摘要的 AI 配置（下拉列表，展示用户可用的 AI 配置）。  
    * “是否覆盖现有摘要”的选项（复选框或开关）。  
  * **API 调用:** 前端点击“开始生成”按钮后，调用后端 API POST /api/tasks/batch-generate-summary，请求体包含 BatchGenerateSummaryParameters DTO。  
* **后台任务类型 (taskType):** BATCH\_GENERATE\_SUMMARY  
* **输入参数 (BatchGenerateSummaryParameters DTO \- 细化):**  
  * novelId (String): 必填，目标小说 ID。  
  * startChapterId (String): 必填，起始章节 ID。  
  * endChapterId (String): 必填，结束章节 ID (包含)。  
  * aiConfigId (String): 必填，用户选择的用于生成摘要的 AI 配置 ID，后端需校验其有效性和用户权限。  
  * overwriteExisting (boolean): 必填，明确指定是否覆盖。  
* **处理流程 (采用子任务模型，增加版本控制 \- 修正服务调用):**  
  1. **父任务启动 (BatchGenerateSummaryTaskExecutable):**  
     * 接收 BatchGenerateSummaryParameters。  
     * 根据 startChapterId 和 endChapterId 从数据库查询需要处理的所有场景 ID (sceneIds) **以及每个场景的当前版本号 (currentVersion)** 列表。  
     * 初始化进度 DTO (BatchGenerateSummaryProgress)，设置 totalScenes。  
     * 通过 TaskContext.updateProgress 汇报初始进度。  
     * **循环提交子任务:** 遍历场景列表：  
       * 对于每个场景 (sceneId, currentVersion)：  
         * 构造 GenerateSummaryParameters DTO，包含 sceneId, aiConfigId, **expectedVersion (值为 currentVersion)**。  
         * 调用 TaskContext.submitSubTask("GENERATE\_SUMMARY", generateSummaryParams) 提交子任务。  
     * 父任务 execute 方法完成。  
  2. **子任务执行 (GenerateSummaryTaskExecutable \- 复用 Task 8.1，增加版本检查，修正服务调用):**  
     * 接收 GenerateSummaryParameters (包含 sceneId, aiConfigId, expectedVersion)。  
     * **读取场景与版本:** 从数据库获取场景内容 (sceneContent) 及其**当前实际版本号 (actualVersion)**。  
       * 如果场景不存在（已被删除），任务失败，发布 TaskFailedEvent（不可重试）。  
     * **版本比较:**  
       * **如果 actualVersion \== expectedVersion (未修改):**  
         * 场景内容未被修改。  
         * **修正调用:** 调用 **NovelAIService.summarizeScene(userId, sceneId, summarizeSceneRequest)** (需要从 aiConfigId 等参数构造 SummarizeSceneRequest) 生成摘要。处理 NovelAIService 调用可能发生的**可重试**和**不可重试**异常。  
         * **原子更新:** 调用 TaskStateService (或 SceneService) 的方法，该方法应原子地更新场景摘要，**并验证版本号**（例如，更新操作的查询条件包含 \_id: sceneId, version: expectedVersion）。如果更新失败（说明在读取和写入之间又被修改了），则按版本不匹配处理（见下文）。如果更新成功，则子任务成功。  
       * **如果 actualVersion \!= expectedVersion (已被修改):**  
         * 场景内容已被用户修改。  
         * **执行策略 B (使用最新内容):**  
           * 记录警告日志，说明检测到版本冲突，将基于最新内容生成摘要。  
           * **修正调用:** 调用 **NovelAIService.summarizeScene(userId, sceneId, summarizeSceneRequest)** 使用当前读取到的最新内容生成摘要。处理 AI 异常。  
           * **尝试原子更新:** 调用 TaskStateService (或 SceneService) 的方法，尝试原子地更新场景摘要，**并验证版本号为 actualVersion**。即使更新失败（用户又改了），也认为此子任务“尝试完成”，记录日志。子任务状态可视为成功或特定状态（如 COMPLETED\_WITH\_CONFLICT）。  
           * **(备选策略 A \- 跳过):** 记录日志，子任务直接成功返回（或特定跳过状态），不生成摘要。需要在父任务进度中体现 skippedCount。  
     * 子任务完成后发布相应的 TaskCompletedEvent 或 TaskFailedEvent。  
  3. **状态聚合 (StateAggregatorService \- 细化):**  
     * 监听 GenerateSummaryTask 的 TaskCompletedEvent 和 TaskFailedEvent。  
     * 根据事件中的 parentTaskId 找到父任务 BatchGenerateSummaryTask。  
     * 原子地更新父任务的 progress DTO (增加 successCount, failedCount, **conflictCount 或 skippedCount**) 和 subTaskStatusSummary。  
     * 检查父任务 progress 中的计数是否达到 totalScenes。  
     * 如果所有子任务完成，根据 failedCount 和 conflict/skippedCount 更新父任务最终状态为 COMPLETED, FAILED, 或 COMPLETED\_WITH\_ERRORS。  
* **输出结果 (BatchGenerateSummaryResult DTO \- 细化):** (增加冲突/跳过计数)  
  * totalScenes (int): 本次任务尝试处理的总场景数。  
  * successCount (int): 成功生成并更新摘要的场景数量（版本匹配且更新成功）。  
  * failedCount (int): 因错误（如场景删除、AI 失败且重试无效）导致失败的场景数量。  
  * conflictCount (int, 可选): 检测到版本冲突并基于最新内容尝试生成的场景数量 (如果采用策略 B)。  
  * skippedCount (int, 可选): 检测到版本冲突并跳过的场景数量 (如果采用策略 A)，或因 overwriteExisting=false 且摘要已存在而跳过的场景数量。  
  * failedSceneDetails (Map\<String, String\>, 可选): 存储失败场景 ID 及其失败原因。  
* **复用性分析:**  
  * **可复用:**  
    * **NovelAIService.summarizeScene(...) 方法。**  
    * GenerateSummaryTaskExecutable (Task 8.1) 作为子任务执行器。  
  * **需新建:**  
    * BatchGenerateSummaryParameters, BatchGenerateSummaryResult, BatchGenerateSummaryProgress DTO。  
    * BatchGenerateSummaryTaskExecutable 作为父任务协调器。  
    * API 端点用于触发此批量任务。  
    * StateAggregatorService 中处理子任务聚合的逻辑。  
* **数据模型依赖:** Scene 实体需要添加 @Version 注解或类似的版本控制字段。

### **2.2 自动续写小说章节内容 (Continue Writing Chapters \- Content)**

* **需求编号:** REQ-TASK-002  
* **关联任务分解:** Task 8.7 (ContinueWritingContentTaskExecutable) 作为父任务，引入新的 Task 8.8 (GenerateSingleChapterTaskExecutable) 作为循环子任务，Task 8.6 (GenerateNextChapterSummariesTaskExecutable \- 可能简化或移除) 和 Task 8.2 (GenerateSceneTaskExecutable) 被 Task 8.8 内部调用或替代。  
* **目标:** 提供连贯、智能的章节续写能力，逐章生成摘要和内容。  
* **用户故事:** 作为一名作者，当我需要扩展故事时，我可以指定续写几章，系统能像一个助手一样，**逐一地**先构思出下一章的摘要，然后根据这个新摘要填充该章的详细内容，并**循环**这个过程，直到达到我指定的章节数。  
* **触发方式:**  
  * **前端交互:** 用户选择小说，输入续写章节数，选择用于生成摘要和内容的 AI 配置。可能提供一个文本框让用户输入额外的上下文或要求 (startContext, writingStyle)。  
  * **API 调用:** POST /api/tasks/continue-writing-content，请求体包含 ContinueWritingContentParameters DTO。  
* **后台任务类型 (taskType):** CONTINUE\_WRITING\_CONTENT  
* **输入参数 (ContinueWritingContentParameters DTO \- 细化):**  
  * novelId (String): 必填。  
  * numberOfChapters (int): 必填，续写数量。  
  * aiConfigIdSummary (String): 必填，摘要生成配置。  
  * aiConfigIdContent (String): 必填，内容生成配置。  
  * startContextMode (Enum: AUTO, LAST\_N\_CHAPTERS, CUSTOM): (新增) 指定如何获取上下文。AUTO 由后端决定（如最后 3 章内容+全局设定），LAST\_N\_CHAPTERS 需配合 contextChapterCount，CUSTOM 需配合 customContext。  
  * contextChapterCount (int, 可选): 当 startContextMode 为 LAST\_N\_CHAPTERS 时使用。  
  * customContext (String, 可选): 当 startContextMode 为 CUSTOM 时使用。  
  * writingStyle (String, 可选): 写作风格提示。  
  * requiresReview (boolean, 可选, 默认 false): 是否需要在生成摘要后暂停，等待用户评审。  
* **处理流程 (复杂工作流 \- 细化为逐章循环子任务):**  
  1. **父任务启动 (ContinueWritingContentTaskExecutable \- Task 8.7):**  
     * 接收 ContinueWritingContentParameters，校验参数。  
     * 初始化进度 DTO (ContinueWritingProgress)，例如 {"totalChapters": N, "chaptersCompleted": 0, "currentStep": "STARTING", "status": "RUNNING"}。  
     * **获取初始上下文:** 根据 startContextMode 从数据库获取用于**第一次**续写的上下文信息 initialContext。  
     * **提交第一个子任务:**  
       * 构造 GenerateSingleChapterParameters DTO，包含 novelId, chapterIndex: 1 (表示这是要生成的第一章), currentContext: initialContext, aiConfigIdSummary, aiConfigIdContent, writingStyle, totalChapters, requiresReview (将父任务参数传递下去)。  
       * 调用 context.submitSubTask("GENERATE\_SINGLE\_CHAPTER", generateChapterParams) 提交**第一个**章节生成子任务。  
     * 更新父任务进度 (currentStep \= "GENERATING\_CHAPTER\_1")。  
     * 父任务 execute 完成。后续流程由子任务和事件驱动。  
  2. **子任务: 生成单章摘要和内容 (GenerateSingleChapterTaskExecutable \- 新建 Task 8.8):**  
     * 接收 GenerateSingleChapterParameters (含 novelId, chapterIndex, currentContext, 配置, totalChapters, requiresReview 等)。  
     * **步骤 2.1: 生成本章摘要:**  
       * 调用 **NovelAIService.generateNextSingleSummary(novelId, currentContext, aiConfigIdSummary, writingStyle)** (需要新增此接口或组合实现) 生成**当前章节**的摘要 currentSummary。处理 AI 异常和重试。  
       * **持久化摘要:** 创建新的 Chapter 记录（或找到预留的记录），保存 currentSummary，状态可能为 DRAFT\_SUMMARY。获取新章节 ID newChapterId。  
       * 通过 context.updateProgress 汇报“摘要已生成”。  
     * **步骤 2.2: (可选) 评审环节:**  
       * 如果 requiresReview 为 true，则子任务在此暂停，发布一个 ChapterSummaryReadyForReviewEvent (包含 parentTaskId, newChapterId, currentSummary)。需要对应的 API (/approve-summary/{chapterId}) 来继续。**子任务在此结束，不继续执行步骤 2.3 和 2.4。** 后续步骤由处理批准 API 的服务触发。  
     * **步骤 2.3: 生成本章内容:**  
       * **准备内容生成上下文:** 可能包含 currentContext、currentSummary 以及可能的全局设定。  
       * 调用 **NovelAIService.generateSceneFromSummaryStream(...)** 使用 aiConfigIdContent 生成本章内容 generatedContent。处理 AI 异常和重试。  
       * **持久化内容:** 将 generatedContent 更新到 newChapterId 对应的 Chapter 或 Scene 记录中，更新章节状态为 DRAFT\_CONTENT 或 COMPLETED。  
     * **步骤 2.4: 准备下一个子任务 (如果需要):**  
       * **判断是否继续:** 检查 chapterIndex \< totalChapters。  
       * **如果需要继续:**  
         * **准备下一轮上下文:** nextContext 可以是 currentContext \+ currentSummary \+ generatedContent (或其他策略，例如只取最后一部分内容)。**上下文管理策略需要仔细设计，避免过长或丢失关键信息。**  
         * 构造 GenerateSingleChapterParameters DTO，包含 chapterIndex: chapterIndex \+ 1, currentContext: nextContext, 及其他配置。  
         * **提交下一个子任务:** 调用 context.submitSubTask("GENERATE\_SINGLE\_CHAPTER", nextChapterParams)。  
     * 子任务成功完成，发布 TaskCompletedEvent (可能包含本章生成的 ID 和摘要/内容摘要)。  
  3. **状态聚合 (StateAggregatorService):**  
     * 监听 GenerateSingleChapterTask 的 TaskCompletedEvent 和 TaskFailedEvent。  
     * 根据事件中的 parentTaskId 找到父任务 ContinueWritingContentTask。  
     * 原子地更新父任务的 progress DTO (增加 chaptersCompleted 计数)。  
     * **判断父任务是否完成:** 检查 chaptersCompleted \== totalChapters。  
     * 如果所有章节处理完毕（无论成功或失败），根据子任务的最终状态聚合结果，更新父任务的最终状态 (COMPLETED, FAILED, COMPLETED\_WITH\_ERRORS)。  
* **输出结果 (ContinueWritingContentResult DTO \- 细化):**  
  * newChapterIds (List): 新创建的章节 ID 列表。  
  * summariesGeneratedCount (int): 成功生成摘要的数量。  
  * contentGeneratedCount (int): 成功生成内容的数量。  
  * status (Enum: COMPLETED, COMPLETED\_WITH\_ERRORS, FAILED, PENDING\_REVIEW): 最终任务状态。  
  * failedSteps (List, 可选): 记录失败的步骤或章节 ID。  
* **复用性分析:**  
  * **可复用:**  
    * **NovelAIService.generateSceneFromSummaryStream(...)**。  
    * Task 8.2 (GenerateSceneTaskExecutable) 的核心逻辑被包含在新的 Task 8.8 中。  
  * **需新建:**  
    * CONTINUE\_WRITING\_CONTENT 任务类型及相关 DTO。  
    * ContinueWritingContentTaskExecutable (Task 8.7) 作为主协调器（仅启动第一个子任务）。  
    * **GENERATE\_SINGLE\_CHAPTER 任务类型及相关 DTO 和 Executable (Task 8.8)。这是核心的循环执行单元。**  
    * **需要 NovelAIService 提供新的 generateNextSingleSummary(...) 方法或组合实现。**  
    * API 端点。  
    * StateAggregatorService 中处理此**循环子任务**的状态聚合逻辑。  
* **未来评审环节:** 设计已包含 requiresReview 参数和 PENDING\_REVIEW 状态，可以在每个章节摘要生成后暂停，等待 API 调用继续。  
* **并发考量:** 每个 GenerateSingleChapterTask 子任务是独立的，可以被不同的消费者实例处理。父任务的状态聚合需要正确处理来自不同子任务的并发事件。

### **2.3 自动续写小说章节摘要 (Continue Writing Chapters \- Summaries Only)**

* **需求编号:** REQ-TASK-003  
* **关联任务分解:** Task 8.9 (GenerateNextSummariesOnlyTaskExecutable) 作为父任务，Task 8.10 (GenerateSingleSummaryTaskExecutable) 作为循环子任务。  
* **目标:** 快速生成后续章节梗概。  
* **用户故事:** 作为一名作者，我有时只想快速看看接下来几章可能写什么，不需要详细内容，这个功能可以帮我快速生成大纲。  
* **触发方式:**  
  * **前端交互:** 用户选择小说，输入续写摘要的章节数，选择 AI 配置。  
  * **API 调用:** POST /api/tasks/generate-next-summaries，请求体包含 GenerateNextSummariesOnlyParameters DTO。  
* **后台任务类型 (taskType):** GENERATE\_NEXT\_SUMMARIES\_ONLY  
* **输入参数 (GenerateNextSummariesOnlyParameters DTO):** (类似 ContinueWritingContentParameters 但不需要 aiConfigIdContent)  
  * novelId (String)  
  * numberOfChapters (int)  
  * aiConfigIdSummary (String)  
  * startContextMode (Enum)  
  * ... (其他上下文参数)  
* **处理流程 (采用循环子任务模型，仅执行摘要生成):**  
  1. **父任务启动 (GenerateNextSummariesOnlyTaskExecutable \- 新建 Task 8.9):**  
     * 接收参数。  
     * 初始化进度。  
     * 获取初始上下文。  
     * **提交第一个摘要子任务:** 构造 GenerateSingleSummaryParameters DTO (包含 chapterIndex: 1, currentContext, aiConfigIdSummary, totalChapters)。调用 context.submitSubTask("GENERATE\_SINGLE\_SUMMARY", ...) (需要新的 Task 8.10)。  
     * 父任务 execute 完成。  
  2. **子任务: 生成单章摘要 (GenerateSingleSummaryTaskExecutable \- 新建 Task 8.10):**  
     * 接收 GenerateSingleSummaryParameters。  
     * 调用 **NovelAIService.generateNextSingleSummary(...)** 生成摘要。处理 AI 异常和重试。  
     * 持久化摘要（创建新 Chapter 记录，状态 DRAFT\_SUMMARY）。获取 newChapterId。  
     * **判断是否继续:** 检查 chapterIndex \< totalChapters。  
     * **如果需要继续:** 准备 nextContext (可以是 currentContext \+ currentSummary)，提交下一个 GENERATE\_SINGLE\_SUMMARY 子任务。  
     * 发布 TaskCompletedEvent (包含 newChapterId 和 summary)。  
  3. **状态聚合 (StateAggregatorService):**  
     * 监听 GenerateSingleSummaryTask 事件。  
     * 更新父任务进度 (chaptersCompleted 计数)。  
     * 当所有摘要生成完毕，更新父任务状态为 COMPLETED，并在父任务结果中聚合所有新章节 ID 和摘要。  
* **输出结果 (GenerateNextSummariesOnlyResult DTO):**  
  * newChapterIds (List): 新章节 ID 列表。  
  * summaries (List): 生成的摘要列表。  
  * status (Enum): 最终任务状态。  
* **复用性分析:**  
  * **可复用:**  
    * **NovelAIService.generateNextSingleSummary(...)** (如果实现)。  
  * **需新建:**  
    * GENERATE\_NEXT\_SUMMARIES\_ONLY 任务类型及相关 DTO。  
    * 父任务协调器 (Task 8.9)。  
    * 单章摘要生成子任务执行器 (Task 8.10)。  
    * API 端点。  
    * StateAggregatorService 中处理此循环子任务的逻辑。  
* **并发考量:** (同 REQ-TASK-002)

## **3\. 对现有功能和接口的复用分析 (深度阐述 \- 修正)**

* **NovelAIService.summarizeScene(...):** 可直接被 GenerateSummaryTaskExecutable (Task 8.1) 复用。REQ-TASK-001 的核心依赖。需要确保其健壮性，能处理不同长度的输入，并返回结构化的结果或明确的错误信息。  
* **NovelAIService.generateSceneFromSummaryStream(...) / generateSceneFromSummary(...):** 可直接被 GenerateSingleChapterTaskExecutable (Task 8.8) 内部复用。REQ-TASK-002 的核心依赖。需要确保其能有效利用上下文信息生成连贯的内容。  
* **NovelAIService.generateNextSingleSummary(...) (需新增或组合实现):** (修正) REQ-TASK-002 和 REQ-TASK-003 的**关键依赖**，用于逐章生成摘要。**必须优先设计和实现此接口**。其内部实现需要考虑如何基于不断增长的上下文生成下一个连贯的摘要。

## **4\. 与 V1.6 任务分解的对应关系 (强化说明 \- 修正)**

* **Task 8.1 (GenerateSummaryTaskExecutable):** 实现 REQ-TASK-001 的**子任务**，核心是调用 **NovelAIService.summarizeScene** 并实现版本检查逻辑。  
* **Task 8.2 (GenerateSceneTaskExecutable):** **职责被 Task 8.8 吸收**。不再需要独立的 Task 8.2 执行器。  
* **Task 8.3 (BatchGenerateSummaryTaskExecutable):** 实现 REQ-TASK-001 的**父任务协调器**，负责查询场景列表（含版本），提交 Task 8.1 子任务。  
* **Task 8.4 (BatchGenerateSceneTaskExecutable):** **建议移除**。  
* **Task 8.5 (ImportNovelTask):** 保持未来规划。  
* **Task 8.6 (GenerateNextChapterSummariesTaskExecutable):** **被重构移除**。  
* **Task 8.7 (ContinueWritingContentTaskExecutable \- 新增):** 实现 REQ-TASK-002 的**父任务启动器**，提交第一个 Task 8.8 子任务。  
* **Task 8.8 (GenerateSingleChapterTaskExecutable \- 新增):** 实现 REQ-TASK-002 的**核心循环子任务**，负责生成单章摘要**和**内容，并提交下一个 Task 8.8。  
* **Task 8.9 (GenerateNextSummariesOnlyTaskExecutable \- 新增):** 实现 REQ-TASK-003 的父任务启动器，提交第一个 Task 8.10 子任务。  
* **Task 8.10 (GenerateSingleSummaryTaskExecutable \- 新增):** 实现 REQ-TASK-003 的核心循环子任务，仅生成单章摘要，并提交下一个 Task 8.10。

## **5\. 并发与数据一致性考量 (深度阐述)**

* **核心问题:** 用户可能在后台任务（尤其是批量处理任务，如 REQ-TASK-001）执行期间，修改任务正在处理的数据（如场景内容）。这会导致竞争条件。  
* **乐观锁机制 (REQ-TASK-001):**  
  * **原理:** 通过版本号字段，允许多个事务并发读取，但在写入时检查版本号是否匹配。如果匹配则写入成功（版本号递增），不匹配则表示数据已被其他事务修改，写入失败并抛出异常（如 OptimisticLockingFailureException）。  
  * **适用性:** 非常适合“读-改-写”模式，且冲突概率相对较低的场景，如更新场景摘要。避免了悲观锁的性能和死锁问题。  
  * **实现细节:**  
    * Scene 实体添加 @Version Long version;。  
    * 父任务读取 sceneId 和 version。  
    * 子任务参数包含 expectedVersion。  
    * 子任务读取时获取 actualVersion。  
    * **写回时:** 使用 TaskStateService 提供的原子更新方法，该方法内部使用 version 作为查询条件 (... where \_id \= ? and version \= ?) 或依赖 Spring Data 的乐观锁异常处理。  
  * **冲突处理策略 (选择 B \- 使用最新，并解释原因):**  
    * **选择原因:** 对于摘要生成，用户通常期望看到基于最新内容的摘要。如果跳过（策略 A），用户可能会困惑为何某些场景没有摘要。如果失败（策略 C），则过于严格，可能导致大量任务进入死信。策略 B 在用户修改优先和任务完成度之间取得了较好平衡。  
    * **实现:** 子任务捕获到版本不匹配（或写回时的乐观锁异常）后，记录警告，然后**重新读取**场景最新内容和版本，再次调用 AI 生成摘要，并**再次尝试**使用新的 actualVersion 进行原子更新。这次更新即使再失败（用户手速极快），也记录日志，认为任务“尽力了”，可以标记为成功或 COMPLETED\_WITH\_CONFLICT。  
    * **用户反馈:** 前端在展示任务结果时，应明确告知用户哪些场景的摘要是基于他们修改后的最新内容生成的。  
* **上下文读取 (REQ-TASK-002, REQ-TASK-003):**  
  * **场景:** 续写任务需要读取之前的章节内容作为上下文。  
  * **策略:** 通常接受基于任务启动时读取到的上下文快照进行续写。因为续写本身就是创作过程，轻微的上下文滞后通常不影响结果质量。如果需要绝对一致，可以在读取上下文时也加入版本检查，并在版本变化时让任务失败或提示用户。**本期采用简单策略，接受基于启动时上下文。**  
* **删除处理:** 子任务在读取数据时发现数据已被删除，应抛出明确的、不可重试的异常（如 SceneNotFoundException），消费者捕获后将其标记为 FAILED 并 NACK（路由到 DLQ）。父任务的状态聚合逻辑需要正确处理这些失败的子任务计数。  
* **DTO 更新:**  
  * BatchGenerateSummaryProgress: 增加 conflictCount。  
  * BatchGenerateSummaryResult: 增加 conflictCount，failedSceneDetails (Map\<String, String\>)。  
  * TaskFailedApplicationEvent: 增加 isConflict 或 failureType 字段。

## **6\. 前端交互与 API 规范 (New Section)**

* **API 端点:**  
  * POST /api/tasks/batch-generate-summary: 触发 REQ-TASK-001。  
  * POST /api/tasks/continue-writing-content: 触发 REQ-TASK-002。  
  * POST /api/tasks/generate-next-summaries: 触发 REQ-TASK-003。  
  * POST /api/tasks/{taskId}/approve-summaries: (用于 REQ-TASK-002 可选评审流程) 批准摘要并继续内容生成。  
  * GET /api/tasks/{taskId}: 获取任务详情（状态、进度、结果、错误）。  
  * GET /api/tasks: 获取用户任务列表（支持分页、按状态过滤）。  
  * DELETE /api/tasks/{taskId}: 取消任务（如果支持）。  
  * GET /api/tasks/dead-letter: (管理员) 查询死信任务。  
  * POST /api/tasks/{taskId}/retry: (管理员) 手动重试死信任务。  
* **请求 DTO:**  
  * /batch-generate-summary: BatchGenerateSummaryParameters。  
  * /continue-writing-content: ContinueWritingContentParameters。  
  * /generate-next-summaries: GenerateNextSummariesOnlyParameters。  
  * /approve-summaries: 可能只需要路径参数 taskId，或包含可选的修改意见。  
* **初始响应:** 所有创建任务的 API (POST) 均返回 202 Accepted 状态码，响应体为 {"taskId": "..."}。  
* **状态追踪:**  
  * **轮询:** 前端可以通过 GET /api/tasks/{taskId} 定期轮询任务状态和进度。API 需返回包含 status, progress (具体进度 DTO 或其序列化形式), result (任务完成后), errorInfo (任务失败时) 的 TaskDetailsDTO。  
  * **WebSocket (推荐):**  
    * 前端连接 WebSocket 服务。  
    * 后端 ExternalEventBridge 将内部 TaskStartedEvent, TaskProgressApplicationEvent, TaskCompletedEvent, TaskFailedEvent 等转换为外部事件发送到 RabbitMQ tasks.events.exchange。  
    * WebSocket 服务监听对应的事件队列，并将任务状态和进度更新实时推送给相关用户的前端。  
* **进度展示:**  
  * 前端需要解析 TaskDetailsDTO.progress 字段（可能是 JSON 字符串或 Map）。  
  * 对于批量任务 (REQ-TASK-001)，应展示总数、已处理、成功、失败、冲突/跳过 的数量或百分比。  
  * 对于续写任务 (REQ-TASK-002)，应展示当前阶段（生成摘要/生成内容/等待评审/完成）以及已完成的章节数 (chaptersCompleted / totalChapters)。  
* **结果展示:**  
  * 任务完成后，前端通过 GET /api/tasks/{taskId} 获取 TaskDetailsDTO.result。  
  * 解析结果 DTO（如 BatchGenerateSummaryResult）并向用户展示摘要信息、成功/失败计数等。  
  * 对于失败的任务，展示 errorInfo 中的错误信息。  
  * 对于有冲突/跳过的任务，提供明确的提示。

**下一步:** 后端团队需要基于此 V1.3 需求文档，**优先设计并实现 NovelAIService.generateNextSingleSummary(...) 接口**。然后按照更新后的任务分解 (特别是新增的 Task 8.7, 8.8, 8.9, 8.10) 进行开发。前端需理解新的续写流程和对应的任务状态变化。