# **后台任务系统 \- 后端任务分解 (AINovalServer) (V1.7 \- WebFlux 响应式版)**

Version: 1.7 (WebFlux 响应式版)  
Date: 2025-04-25  
Based on: 后台任务系统后端任务分解 (V1.6 \- MQ+事件深度扩展终版)  
Changes:

* **全面适配 WebFlux:** 对整个任务分解进行了调整，以符合 Spring WebFlux 响应式编程模型 (Mono, Flux, Schedulers)。  
* **更新签名:** API、Service、Repository、Task Executable 的方法签名更新为返回响应式类型。  
* **明确线程模型:** 强调了 WebFlux 事件循环与阻塞操作处理（使用 Schedulers），以及 AMQP Listener 线程与响应式链的交互。  
* **调整组件交互:** 细化了在响应式流程中进行数据库操作、MQ ACK/NACK、事件发布/监听的方式。  
* **增强实现说明:** 对关键组件（消费者、执行器、状态服务）的响应式实现提供了更具体的指导。

**目标:** 基于 V1.6 的 MQ+事件架构，提供一个完全适配 AINovalServer (Spring WebFlux) 的后台任务系统后端开发任务分解，确保非阻塞、高效和资源利用率。

**核心架构:** RabbitMQ \+ Spring AMQP \+ Spring Application Events \+ Spring WebFlux \+ Reactive MongoDB

## **0\. 架构概览与核心组件职责 (响应式视角)**

架构图和核心组件职责基本保持 V1.6 不变，但需要强调**非阻塞**特性和**响应式流**的处理：

* **数据流:** 请求和数据在组件间以 Mono 或 Flux 的形式流动。  
* **线程模型:**  
  * WebFlux API 层运行在 Netty 事件循环线程上，**严禁阻塞**。  
  * MQ 消费者 (@RabbitListener) 运行在 Spring AMQP 的独立线程池上（通常是平台线程）。这是**从阻塞世界到响应式世界的桥梁**。  
  * 任务执行 (BackgroundTaskExecutable.execute()) 中的 IO 或 CPU 密集型操作**必须**通过 subscribeOn() 或 publishOn() 切换到合适的 Scheduler (如 Schedulers.boundedElastic() 用于阻塞 IO，Schedulers.parallel() 用于 CPU 密集计算)。  
  * 数据库操作使用 Reactive MongoDB 驱动，本身是非阻塞的。  
  * Spring 事件监听器如果执行阻塞操作，需要 @Async 或调度到 boundedElastic；如果执行响应式操作，应返回 Mono\<Void\>。

**核心组件图示 (同 V1.6):**

graph LR  
    A\[API Layer / Producer\] \-- 1\. Task Request (HTTP, Reactive) \--\> SUBMIT(Task Submission Service);  
    SUBMIT \-- 2\. Create Record (QUEUED, Reactive) \--\> DB\[(MongoDB \- Task State)\];  
    SUBMIT \-- 3\. Publish Internal Event (TaskSubmittedEvent, Reactive Chain) \--\> SEB{Spring Event Bus};  
    SEB \-- 4\. Listener Triggers MQ Send \--\> MQPROD(Task Message Producer);  
    MQPROD \-- 5\. Send Task Message (AMQP, Persistent, Confirms Enabled) \--\> MQ(\[RabbitMQ Exchanges/Queues\]);  
    MQ \-- 6\. Deliver Task Message (Blocking Listener Thread) \--\> CONSUMER(Task Consumer @RabbitListener);  
    CONSUMER \-- 7\. Start Reactive Chain \--\> CONSUMER\_REACTIVE(Reactive Processing);  
    CONSUMER\_REACTIVE \-- 8\. Idempotency Check & Find Executor (Reactive) \--\> EXEC(Task Executor Service);  
    CONSUMER\_REACTIVE \-- 8a. Update Status (RUNNING, Atomic, Reactive) \--\> DB;  
    CONSUMER\_REACTIVE \-- 8b. Publish Internal Event (TaskStartedEvent, Reactive) \--\> SEB;  
    EXEC \-- 9\. Delegate Execution (Returns Mono\<R\>) \--\> TASKEXEC(BackgroundTaskExecutable);  
    TASKEXEC \-- 10\. Business Logic (Reactive Chain, subscribeOn for blocking IO) \--\> S((External Services / AI / DB));  
    TASKEXEC \-- 11\. Report Progress (Triggers Event in Reactive Chain) \--\> CONSUMER\_REACTIVE;  
    CONSUMER\_REACTIVE \-- 11a. Publish Internal Event (TaskProgressEvent, Reactive) \--\> SEB;  
    TASKEXEC \-- 12\. Submit Sub-Task Request \--\> MQPROD;  
    CONSUMER\_REACTIVE \-- 13\. Handle Result/Exception & Publish Internal Events (Reactive) \--\> SEB;  
    CONSUMER\_REACTIVE \-- 14\. ACK/NACK Message (doFinally/doOnError in Reactive Chain) \--\> MQ;  
    SEB \-- 15\. Handle Internal Events (Async/Reactive Listener) \--\> LISTENER1(State Aggregator Service @EventListener);  
    LISTENER1 \-- 16\. Update DB State (Atomic, Idempotent, Reactive) \--\> DB;  
    SEB \-- 17\. Handle Internal Events \--\> LISTENER2(External Event Bridge @EventListener);  
    LISTENER2 \-- 18\. Convert & Publish External Event \--\> EVTPUB(External Event Publisher);  
    EVTPUB \-- 19\. Send Event Message (AMQP) \--\> MQ;  
    MQ \-- 20\. Deliver Event Message \--\> EXT\_SUB(External Subscribers \- WS, Notify);

    style DB fill:\#f9f,stroke:\#333,stroke-width:2px  
    style MQ fill:\#ccf,stroke:\#333,stroke-width:2px  
    style SEB fill:\#ff9,stroke:\#333,stroke-width:1px,stroke-dasharray: 5 5

**核心组件职责 (响应式调整):**

* **API Layer / Producer:** Controller 方法返回 Mono\<ResponseEntity\<TaskCreateResponse\>\> 或类似类型。  
* **Task Submission Service:** 方法返回 Mono\<String\> (包含 taskId)。内部数据库操作和事件发布都在响应式链中完成。  
* **Task Message Producer:** sendTaskMessage 方法可以是同步或异步（返回 Mono\<Void\>，处理 Confirm/Return 回调）。  
* **MongoDB (Task State):** 使用 ReactiveMongoRepository。  
* **Task Consumer (@RabbitListener):** **关键转换点**。handleTaskMessage 方法内部**立即**启动一个 Mono 或 Flux 链来处理消息。ACK/NACK 操作放在链的 doFinally, doOnError, doOnSuccess 等操作符中执行。  
* **Task Executor Service:** executeTask 方法返回 Mono\<R\> 或 Mono\<ExecutionResult\>。  
* **BackgroundTaskExecutable:** execute 方法返回 Mono\<R\>。内部实现必须是响应式的，阻塞调用需使用 subscribeOn(Schedulers.boundedElastic())。  
* **State Aggregator Service (@EventListener):** 监听器方法如果执行 DB 操作，应返回 Mono\<Void\> 并使用响应式 Repository。如果执行阻塞操作，需 @Async 或调度。  
* **External Event Bridge (@EventListener):** 类似 State Aggregator。  
* **External Event Publisher:** publishExternalEvent 方法可以是同步或返回 Mono\<Void\>。

## **1\. 核心框架、模型与 DTO 定义 (Foundation, Models & DTOs \- 响应式调整)**

* **\[Task-Core-01\] 定义任务状态枚举 (TaskStatus.java):** (同 V1.6) ...  
* **\[Task-Core-02\] 定义后台任务数据模型 (BackgroundTask.java):** (同 V1.6) ...  
* **\[Task-Core-03\] 定义任务执行器接口 (BackgroundTaskExecutable\<P, R\>):** (调整返回类型)  
  * 泛型: \<P, R\>。  
  * 方法:  
    * **Mono\<R\> execute(TaskContext\<P\> context);**: **(关键修改)** 返回 Mono\<R\>，表示异步执行并最终产生结果 R 或错误。  
    * String getTaskType();  
    * Class\<P\> getParameterType();  
    * Class\<R\> getResultType();  
    * (可选) Mono\<Void\> reportProgress(TaskContext\<P\> context, Object progressData);  
    * (可选) boolean isCancellable();  
    * (可选) Mono\<Void\> cancel(TaskContext\<P\> context);  
    * (可选) 生命周期钩子: Mono\<Void\> onQueued(TaskContext\<P\> context) {}, ... (钩子也应返回 Mono\<Void\>)。  
  * 复杂度: 高  
* **\[Task-Core-04\] 定义任务上下文接口 (TaskContext\<P\>):** (调整返回类型)  
  * 方法: getTaskId(), getUserId(), P getParameters(), getParentTaskId(), Mono\<Void\> updateProgress(Object progressData), void logInfo(...), void logError(...), **Mono\<String\> submitSubTask(String taskType, Object subTaskParameters);** (提交子任务也应是异步的)。  
  * 复杂度: 中  
* **\[Task-Core-DTO-01\] 定义所有任务的 Parameters/Result/Progress DTO:** (同 V1.6) ...  
* **\[Task-Core-Event-01\] 定义 Spring Application Event 类:** (同 V1.6) ...  
* **\[Task-Core-Event-02\] 定义外部事件 DTO (TaskExternalEvent.java):** (同 V1.6) ...

## **2\. 持久化层 (Persistence Layer \- 响应式实现)**

* **\[Task-Persist-01\] 创建 Reactive MongoDB Repository (BackgroundTaskRepository.java):** (明确使用 Reactive)  
  * 位置: com.ainovel.server.repository  
  * 继承: **ReactiveMongoRepository\<BackgroundTask, String\>**。  
  * 方法: 所有方法签名返回 Mono\<BackgroundTask\>, Flux\<BackgroundTask\>, Mono\<Boolean\>, Mono\<Void\> 等响应式类型。  
    * findByUserId(String userId, Pageable pageable): Flux\<BackgroundTask\>  
    * findByIdAndUserId(String id, String userId): Mono\<BackgroundTask\>  
    * ... 其他查询 ...  
  * **原子更新:** 使用 ReactiveMongoTemplate 的 findAndModify 或响应式乐观锁 (@Version 配合 save）。  
  * 复杂度: 中  
* **\[Task-Persist-02\] 实现状态数据库服务 (TaskStateService.java):** (明确使用 Reactive)  
  * 位置: com.ainovel.server.task.service  
  * 注入: **ReactiveMongoRepository**, ObjectMapper。  
  * 方法签名返回 Mono 或 Flux。  
    * Mono\<BackgroundTask\> createTask(...)  
    * Mono\<Boolean\> trySetRunning(String taskId)  
    * Mono\<Void\> recordProgress(String taskId, Object progressData)  
    * Mono\<Void\> recordCompletion(String taskId, R result)  
    * Mono\<Void\> recordFailure(String taskId, Map\<String, Object\> errorInfo, boolean isDeadLetter)  
  * 内部调用 Repository 的响应式方法，并组合响应式操作符（flatMap, map, then 等）。  
  * 复杂度: 中-高

## **3\. 消息队列基础设施与配置 (MQ Infrastructure & Configuration \- 响应式调整)**

* **\[Task-MQ-Infra-01\] 配置 RabbitMQ 拓扑结构:** (同 V1.6) ...  
* **\[Task-MQ-Infra-02\] 配置 RabbitTemplate:** (同 V1.6) ...  
* **\[Task-MQ-Infra-03\] 配置 RabbitListener Container Factory:** (细化响应式交互)  
  * (同 V1.6 前几点) Manual Ack, Concurrency, Prefetch, Error Handler。  
  * **虚拟线程/调度器:** (同 V1.6) 推荐配置 Listener Factory 使用虚拟线程 taskExecutor，或者确保消费者内部的响应式链能正确调度阻塞操作。  
  * 复杂度: 中

## **4\. 任务生产者组件 (Task Producer Components \- 响应式调整)**

* **\[Task-MQ-Prod-01\] 实现任务消息生产者服务 (TaskMessageProducer.java):** (可选返回 Mono)  
  * 方法: Mono\<Void\> sendTask(...) (返回 Mono 以便组合，并在成功或失败时发出信号)。  
  * 逻辑: 使用 rabbitTemplate.convertAndSend。处理 Confirm/Return 回调可以通过 RabbitTemplate 的 invoke 方法结合 Mono.create 或 Mono.fromFuture 来包装成响应式。  
  * 复杂度: 中  
* **\[Task-Submit-01\] 实现任务提交服务 (TaskSubmissionService.java):** (返回 Mono)  
  * 方法: Mono\<String\> submitTask(...)。  
  * 逻辑:  
    * **推荐逻辑 (带内部事件):**  
      // @Transactional // 注意：标准 @Transactional 不适用于响应式流  
      // 需要使用响应式事务管理器 TransactionalOperator  
      return transactionalOperator.execute(status \-\> // 1\. 使用 TransactionalOperator  
          taskStateService.createTask(userId, taskType, paramsDTO) // 2\. 创建 DB 记录 (返回 Mono\<BackgroundTask\>)  
              .flatMap(task \-\> {  
                  applicationEventPublisher.publishEvent(new TaskSubmittedEvent(task.getId(), ...)); // 3\. 发布事件  
                  return Mono.just(task.getId()); // 4\. 返回 taskId  
              })  
      ).single(); // 确保事务执行并返回 taskId

    * **替代逻辑 (直接发 MQ):**  
      return taskStateService.createTask(...)  
          .flatMap(task \-\> taskMessageProducer.sendTask(task.getId(), ...)  
                               .thenReturn(task.getId())); // 发送成功后返回 taskId

  * 复杂度: 中-高 (响应式事务处理)  
* **\[Task-Submit-Listener-01\] 实现 TaskSubmittedEvent 监听器 (可选):** (返回 Mono)  
  * 方法: @EventListener public Mono\<Void\> onTaskSubmitted(TaskSubmittedEvent event)。  
  * 逻辑: 调用 taskMessageProducer.sendTask(...) 并返回其 Mono\<Void\>。  
  * 复杂度: 低

## **5\. 任务消费者与执行器组件 (Task Consumer & Executor Components \- 响应式实现)**

* **\[Task-Consume-01\] 实现主任务消费者 (TaskConsumer.java):** (核心响应式转换)  
  * 方法: @RabbitListener(...) public void handleTaskMessage(Message message, Channel channel) throws IOException。  
  * **核心逻辑 (启动响应式链):**  
    long deliveryTag \= message.getMessageProperties().getDeliveryTag();  
    try {  
        // 1\. 启动 Mono 链来处理消息  
        processMessageReactively(message)  
            .doOnSuccess(result \-\> {  
                // 成功处理  
                ackMessage(channel, deliveryTag, "success");  
            })  
            .doOnError(RetryableException.class, e \-\> {  
                // 可重试失败  
                handleRetryableError(message, channel, deliveryTag, e);  
            })  
            .doOnError(NonRetryableException.class, e \-\> {  
                // 不可重试失败  
                handleNonRetryableError(message, channel, deliveryTag, e, false);  
            })  
            .doOnError(error \-\> \!(error instanceof RetryableException || error instanceof NonRetryableException), e \-\> {  
                 // 意外错误  
                log.error("Unexpected error processing task...", e);  
                handleNonRetryableError(message, channel, deliveryTag, e, true); // 视为死信  
            })  
            .doFinally(signalType \-\> {  
                // 确保在各种情况下（包括取消）都有处理  
                log.debug("Reactive chain finished for deliveryTag {}: {}", deliveryTag, signalType);  
            })  
            .subscribeOn(Schedulers.boundedElastic()) // 将整个处理链（包括潜在阻塞）放到 BoundedElastic  
            .subscribe(); // 触发执行

    } catch (Exception e) {  
        // 处理 handleTaskMessage 方法本身的同步异常 (例如反序列化前的基础解析错误)  
        log.error("Error before starting reactive chain for deliveryTag {}", deliveryTag, e);  
        nackMessage(channel, deliveryTag, false); // 通常直接 NACK，可能进 DLQ  
    }

  * **processMessageReactively(Message message): Mono\<R\> 方法:**  
    1. 解析消息头和消息体。  
    2. taskStateService.trySetRunning(taskId) (返回 Mono\<Boolean\>)。  
    3. .filter(acquired \-\> acquired) 如果获取锁失败则链终止 (触发 doFinally 但无错误)。  
    4. .flatMap(acquired \-\> findExecutorAndDeserialize(taskType, messageBody))。  
    5. .flatMap(pair \-\> { executable \= pair.getT1(); context \= pair.getT2(); return Mono.just(executable); })。  
    6. .doOnNext(exec \-\> applicationEventPublisher.publishEvent(new TaskStartedEvent(...)))。  
    7. .flatMap(exec \-\> taskExecutorService.executeTask(exec, context)) (返回 Mono\<R\>)。  
    8. .doOnNext(result \-\> applicationEventPublisher.publishEvent(new TaskCompletedEvent(..., result)))。  
  * **ACK/NACK 封装:** 创建 ackMessage(...) 和 nackMessage(...) 方法处理 IOException。  
  * **错误处理方法:** handleRetryableError, handleNonRetryableError 内部包含发布事件和 NACK 逻辑。  
  * 复杂度: 高 (响应式编程和错误处理复杂)  
* **\[Task-Consume-Retry-01\] 实现重试路由/发布逻辑:** (响应式)  
  * 在 handleRetryableError 方法中：  
    * 计算延迟 delayMillis。  
    * 构造新消息属性。  
    * **调用 rabbitTemplate.convertAndSend(...) (返回 Mono\<Void\>)**。  
    * .then(Mono.fromRunnable(() \-\> nackMessage(channel, deliveryTag, false))) // 重新发布成功后 NACK 原消息  
    * .onErrorResume(sendError \-\> ...) // 处理重新发布失败  
  * 复杂度: 中  
* **\[Task-Exec-Svc-01\] 实现任务执行器服务 (TaskExecutorService.java):** (返回 Mono)  
  * Mono\<BackgroundTaskExecutable\<?, ?\>\> findExecutor(String taskType)。  
  * **Mono\<R\> executeTask(BackgroundTaskExecutable\<P, R\> executable, TaskContext\<P\> context):**  
    * 调用 executable.execute(context) (返回 Mono\<R\>)。  
    * **.onErrorMap(e \-\> classifyException(e))**: 使用 onErrorMap 或 onErrorResume 对异常进行分类，包装成 RetryableException 或 NonRetryableException。  
  * 复杂度: 中  
* **\[Task-Exec-Impl-01..N\] 实现具体的 BackgroundTaskExecutable\<P, R\>:** (返回 Mono)  
  * **Mono\<R\> execute(TaskContext\<P\> context):**  
    * 内部所有 IO 操作（DB 查询、AI 调用）都应使用响应式 API。  
    * 如果必须调用阻塞 API，使用 Mono.fromCallable(() \-\> blockingApiCall()).subscribeOn(Schedulers.boundedElastic())。  
    * 使用 flatMap, map, zip, then 等操作符组合异步流程。  
    * **子任务提交:** context.submitSubTask(...) 返回 Mono\<String\>，使用 flatMap 链接。  
    * **进度汇报:** context.updateProgress(...) 返回 Mono\<Void\>，使用 then 或 flatMap 链接。  
  * 复杂度: 中-高

## **6\. 事件处理组件 (Event Handling Components \- 响应式调整)**

* **\[Task-Event-State-01\] 实现状态聚合服务 (StateAggregatorService.java):** (响应式监听器)  
  * **监听器方法签名:** @EventListener public Mono\<Void\> handleTaskStarted(TaskStartedEvent event)。返回 Mono\<Void\> 表明是响应式处理。  
  * **实现:** 调用 TaskStateService 的响应式方法更新数据库。return taskStateService.trySetRunning(event.getTaskId()).then();。  
  * **异步:** 如果监听器本身是响应式的，通常不需要 @Async。Spring 会自动处理 Mono\<Void\> 的订阅。如果内部有阻塞调用，仍需调度。  
  * **幂等性:** (同 V1.6) 实现逻辑需适应响应式链。  
  * 复杂度: 中-高  
* **\[Task-Event-Bridge-01\] 实现外部事件桥接器 (ExternalEventBridge.java):** (响应式监听器)  
  * 方法签名: @EventListener public Mono\<Void\> bridgeTaskCompleted(TaskCompletedEvent event)。  
  * 实现: 调用 TaskEventPublisher.publishExternalEvent(...) (其应返回 Mono\<Void\>)。  
  * 复杂度: 中  
* **\[Task-Event-Pub-Ext-01\] 实现外部事件发布器 (TaskEventPublisher.java):** (返回 Mono)  
  * 方法: Mono\<Void\> publishExternalEvent(TaskExternalEvent event)。  
  * 逻辑: 使用 RabbitTemplate 发送，并处理 Confirm/Return 回调，包装成 Mono\<Void\>。  
  * 复杂度: 中  
* **\[Task-Event-Sub-Ext-01..N\] 实现外部事件订阅者:** (使用响应式客户端，如 Reactor RabbitMQ Client 或 Project Reactor 适配的 Spring AMQP)  
  * 推荐使用 Reactor RabbitMQ Client (reactor-rabbitmq) 或 Spring Boot 3.x 对响应式 @RabbitListener 的支持（如果适用）。  
  * 复杂度: 中

## **7\. 其他支持组件与配置 (Supporting Components & Configuration \- 响应式调整)**

* **\[Task-Support-RateLimit-01\] 实现限流服务 (RateLimiterService.java):**  
  * 如果使用 Resilience4j，其有响应式 RateLimiter 支持 (RateLimiterOperator)，可以整合到 Mono/Flux 链中。  
  * 如果使用 Guava 或内存实现，调用 acquirePermit 是阻塞的，需要在 boundedElastic 上执行。  
  * 复杂度: 中-高  
* **\[Task-Support-Config-01\] 添加相关配置到 application.yml:** (同 V1.6) ...  
* **\[Task-Support-Log-01\] 配置详细日志记录:** (强调响应式上下文传递)  
  * **MDC:** 在 WebFlux 中传递 MDC 需要特殊处理。使用 context-propagation 库或 Reactor Context \+ Logback/Log4j2 的集成来传递 traceId 等信息。  
  * 复杂度: 中  
* **\[Task-Support-Monitor-01\] 添加监控指标:** (同 V1.6) ...  
* **\[Task-Support-Recovery-01\] 实现死信处理机制/API:** (API 返回 Mono/Flux) ...  
* **\[Task-Support-Shutdown-01\] 实现优雅停机:** (同 V1.6) ...

## **8\. 集成与测试 (Integration & Testing \- 响应式测试)**

* **单元测试:** (同 V1.4)  
* **集成测试 (使用 Testcontainers):**  
  * **响应式测试:** 使用 StepVerifier (来自 reactor-test 库) 来测试 Mono 和 Flux 的行为，验证事件序列、完成信号、错误信号等。  
  * **覆盖场景:** (同 V1.6) 测试 Happy Path, Retry, DLQ, Idempotency, Concurrency, Eventing, Sub-task，**确保在响应式流程中这些机制按预期工作**。  
  * **调度器验证:** 验证阻塞操作是否确实被调度到了 boundedElastic 或其他预期线程池。  
* 复杂度: 高

## **9\. 文档 (Documentation \- 响应式更新)**

* **API 文档:** 明确 API 返回 Mono/Flux。  
* **架构文档:** 更新本文档 V1.7，强调响应式流程、线程模型转换、关键组件的响应式签名和实现要点。  
* **开发者指南:** 提供响应式编程的最佳实践，如何处理阻塞调用，如何使用 StepVerifier 进行测试。  
* 复杂度: 中

**依赖关系与顺序建议:** (基本同 V1.6，但所有实现需考虑响应式)

这个 V1.7 版本在 V1.6 的基础上，全面融入了 Spring WebFlux 的响应式编程模型，对所有涉及异步和 IO 的操作都采用了 Mono 和 Flux 进行建模，并明确了线程调度策略。这将使得后台任务系统能够更好地利用 WebFlux 的非阻塞优势，提高资源利用率和系统吞吐量。