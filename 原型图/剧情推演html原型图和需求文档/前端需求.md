# 前端需求文档 - 剧情推演 (Next Outline Generation) 功能

**版本:** 1.1
**日期:** 2025年4月25日
**基于后端需求:** `next_outline_backend_reqs_v1` (v1.3)
**基于前端原型:** `next_outline_prototype_v3`
**变更记录:**
* v1.1: 更新与后端实现对齐，明确 SSE 数据处理流程，补充标题提取逻辑，完善 API 交互细节。

## 1. 功能概述

在 Flutter 应用中新增"剧情推演"功能模块。该模块允许用户基于当前打开的小说，选择一段章节范围作为上下文，调用后端 AI 服务生成多个后续剧情大纲选项（包含标题和摘要）。用户可以浏览这些选项，对不满意的选项进行单独的模型选择和重新生成，最终选择一个满意的大纲，并将其保存为小说的一个新章节及其首个场景。

## 2. 目标用户

小说作者、编剧。

## 3. 功能目标

* 提供直观易用的界面，让用户可以方便地配置生成参数、浏览结果、进行交互。
* 实现流畅的流式数据显示（打字机效果），提升用户体验。
* 有效管理功能状态（加载、错误、结果显示、单项刷新等）。
* 与现有 Flutter 应用（导航、主题、状态管理、API 服务）无缝集成。

## 4. 功能性需求

### 4.1 导航集成

* 在主要的导航区域（例如 `EditorScreen` 的 `EditorAppBar` 或应用的侧边栏/底部导航栏，需根据最终设计定夺）添加一个新的导航入口，标签为"剧情推演"。
* 点击该入口后，应导航到新的 `NextOutlineScreen` 页面，并传递当前正在编辑的小说的 `novelId`。

### 4.2 剧情推演屏幕 (`NextOutlineScreen`)

* **屏幕结构:**
    * **AppBar:** 显示页面标题，例如"剧情推演 - [小说标题]"。包含返回按钮。
    * **主内容区 (ScrollView):**
        * **配置面板 (Widget A):** 对应原型图顶部的配置区域。
        * **结果区域 (Widget B):** 对应原型图下方的结果展示区域。

* **Widget A: 配置面板 (`OutlineGenerationConfigCard`)**
    * UI 样式需与原型图一致 (圆角卡片、内边距等)。
    * **上下文章节选择:**
        * 提供两个下拉选择器 (`DropdownButtonFormField` 或自定义下拉组件):
            * "上下文开始章节" (`startChapterSelect`) - 可选，null 表示从第一章开始
            * "上下文结束章节" (`endChapterSelect`) - 可选，null 表示到最后一章
        * 下拉框选项应动态加载当前 `novelId` 对应的章节列表（章节 ID 和标题）。此数据需从 `EditorBloc` Ø或通过 `NovelRepository` 获取。
        * 需处理默认选中项（例如，开始章节默认第一章，结束章节默认最后一章）。
        * 需要校验：结束章节不能早于开始章节。如果用户选择了无效组合，显示错误提示且禁用生成按钮。
    * **生成选项数量:**
        * 提供下拉选择器 (`numOptionsSelect`) 让用户选择希望生成的剧情选项数量（例如 2-5）。
    * **作者偏好/引导:**
        * 提供多行文本输入框 (`TextField`) 让用户输入可选的引导信息 (`authorGuidanceTextarea`)。
    * **AI 模型选择:**
        * 提供多选或列表组件 (`CheckboxListTile` 等)，让用户选择一个或多个希望用于生成的 AI 模型配置 (`selectedConfigIds`)。
        * 如果选择的模型数量小于请求的生成选项数量，前端应显示提示信息："部分模型将被重复使用"。
    * **生成按钮:**
        * 一个醒目的按钮 (`ElevatedButton`)，标签为"生成剧情大纲"。
        * 点击后，收集所有配置参数，触发 `NextOutlineBloc` 发起初始生成事件。
        * 按钮在生成过程中应显示加载状态或禁用。

* **Widget B: 结果区域 (`OutlineResultsArea`)**
    * **标题:** 显示"生成结果"文本。
    * **状态显示:**
        * **全局加载状态 (`LoadingIndicator`):** 在调用初始生成或全局重新生成 API 时显示（对应原型 `loading-state`）。
        * **空状态 (`EmptyStatePlaceholder`):** 在首次进入或没有生成结果时显示（对应原型 `empty-state`）。
        * **错误状态:** 当 API 调用失败或 SSE 连接错误时，显示用户友好的错误提示信息和可能的重试按钮。
    * **结果网格 (`ResultsGrid`)**:
        * 使用响应式布局（如 `GridView.builder` 配合 `LayoutBuilder` 或 `flutter_staggered_grid_view`）来展示结果卡片，适配不同屏幕尺寸（对应原型 `results-grid`）。
        * 根据 `NextOutlineBloc` 的状态动态构建卡片列表。
    * **结果卡片 (`ResultCard`)**:
        * **唯一标识:** 存储 `optionId`（由后端生成并通过 SSE 事件传递）。
        * **加载遮罩:** 包含一个覆盖层，在单独重新生成该卡片时显示加载动画（对应原型 `card-loading-overlay`）。
        * **标题显示:**
            * 显示从 SSE 收到的 `optionTitle`。
            * **注意:** 标题可能在第一个或后续 chunk 中出现，前端需要累积并提取。在接收到标题前，可显示"生成中..."占位符。
        * **内容显示:**
            * 流式显示从 SSE 收到的 `textChunk`。
            * **实现打字机效果:** 可以使用现有 `ai_stream_generation_display.dart` 或类似逻辑，或者引入 `animated_text_kit` 等库。
        * **底部操作区:**
            * **模型选择下拉框 (`regenerateModelSelect`):**
                * 显示用户已配置的 AI 模型列表 (`UserAIModelConfig`)。此列表需从 `AiConfigBloc` 或 `UserAIModelConfigRepository` 获取。
                * 允许用户为该卡片的下一次重新生成选择不同的模型。
            * **单项刷新按钮 (`regenerateSingleButton`):**
                * 一个带刷新图标的按钮 (`IconButton` 或 `TextButton.icon`)。
                * 点击后，获取当前卡片的 `optionId` 和模型下拉框中选中的 `configId`，触发 `NextOutlineBloc` 发起单个选项重新生成事件。
            * **选择大纲按钮 (`selectOutlineButton`):**
                * 根据当前卡片是否被选中，显示不同样式（如原型所示，选中时高亮）。
                * 点击后，更新 `NextOutlineBloc` 中的选中状态，并触发保存操作（或提供单独的保存按钮）。
    * **全局操作按钮 (`GlobalActionButtons`)**:
        * **重新生成(全部)按钮:** 点击后触发 `NextOutlineBloc` 发起全局重新生成事件，使用相同的上下文范围参数（`startChapterId` 和 `endChapterId`）。
        * **提示输入框:** `TextField` 用于输入全局提示。
        * **提示并重试(全部)按钮:** 点击后，获取提示内容，触发 `NextOutlineBloc` 发起带提示的全局重新生成事件。

### 4.3 状态管理 (`NextOutlineBloc`)

* **职责:** 管理 `NextOutlineScreen` 的状态，处理用户交互事件，与后端 API 交互。
* **依赖:** `NovelRepository`, `UserAIModelConfigRepository` (或对应 Bloc), `SseClient`。
* **状态 (`NextOutlineState`):**
    * `novelId`: 当前小说 ID。
    * `chapters`: 小说章节列表 (用于填充下拉框)。
    * `aiModelConfigs`: 可用 AI 模型配置列表 (用于填充下拉框)。
    * `startChapterId`: 当前选中的上下文开始章节 ID。
    * `endChapterId`: 当前选中的上下文结束章节 ID。
    * `generationStatus`: 当前状态枚举 (e.g., `initial`, `loadingChapters`, `loadingModels`, `generatingInitial`, `generatingSingle`, `idle`, `error`, `saving`)。
    * `outlineOptions`: `List<OutlineOptionState>` - 当前显示的剧情选项列表。
    * `selectedOptionId`: 当前用户选中的剧情选项 ID (可选)。
    * `errorMessage`: 错误信息。
* **`OutlineOptionState` (嵌套状态):**
    * `optionId`: 唯一标识符。
    * `title`: AI 生成的标题 (可能逐步更新)。
    * `contentStreamController`: 用于接收和缓冲 SSE 发来的 `textChunk`。
    * `fullContent`: 拼接完成的完整内容。
    * `isGenerating`: 是否正在单独重新生成此选项。
    * `error`: 此选项相关的错误信息。
    * `isFinalChunk`: 是否已接收到最后一个 chunk。
* **事件 (`NextOutlineEvent`):**
    * `LoadData(String novelId)`: 加载章节和模型列表。
    * `GenerateInitialRequested(GenerateNextOutlinesRequest request)`: 请求初始生成。
    * `RegenerateSingleRequested(RegenerateOutlineOptionRequest request)`: 请求重新生成单个选项。
    * `GlobalRegenerateRequested()`: 请求全局重新生成（使用当前 `startChapterId` 和 `endChapterId`）。
    * `GlobalRegenerateWithHintRequested(String hint)`: 请求带提示的全局重新生成。
    * `_SseChunkReceived(OutlineGenerationChunk chunk)`: (内部事件) 处理收到的 SSE 数据块。
    * `_SseErrorOccurred(String optionId, String error)`: (内部事件) 处理 SSE 错误。
    * `_SseConnectionClosed()`: (内部事件) 处理 SSE 连接关闭。
    * `OptionSelected(String optionId)`: 用户选择了一个选项。
    * `SaveSelectedOutlineRequested(AddChapterFromOutlineRequest request)`: 请求保存选中的大纲。
* **核心逻辑:**
    * 初始化时加载章节和模型数据。
    * 处理生成请求事件，调用相应的 Repository 方法发起 API 请求。
    * **管理 SSE 连接:** 对于 `generate-next-outlines` 和 `regenerate-outline-option` API，建立 SSE 连接，监听事件。
    * **处理 SSE 数据:**
        * 解析 `OutlineGenerationChunk`，根据 `optionId` 找到对应的 `OutlineOptionState`。
        * 更新 title：如果 chunk 中包含 `optionTitle`，则更新卡片标题。
        * 将 `textChunk` 通过 `contentStreamController` 推送给 UI 层。
        * 当接收到 `isFinalChunk=true` 的 chunk 时，标记该选项生成完成。
        * 使用 `emit` 更新 BLoC 状态以驱动 UI 刷新。
    * 处理 SSE 错误和连接关闭事件，更新状态。
    * 管理卡片的选中状态。
    * 处理保存请求，调用 Repository 方法，更新状态（显示加载、成功或失败）。

### 4.4 API 集成 (`NovelRepository` / `NextOutlineRepository`)

* 需要添加或修改 Repository 层的方法来调用以下后端 API:
    * `POST /api/novels/{novelId}/ai/generate-next-outlines`:
        * **请求参数:** 构建 `GenerateNextOutlinesRequest` 对象，包含 `novelId`, `startChapterId`, `endChapterId`, `numberOfOptions`, `authorGuidance`, `selectedConfigIds` 列表，以及可选的 `regenerateHint`。
        * 需要使用 `SseClient` 来处理流式响应。
        * 返回一个 `Stream<OutlineGenerationChunk>` 给 BLoC。
    * `POST /api/novels/{novelId}/ai/regenerate-outline-option`:
        * **请求参数:** 构建 `RegenerateOutlineOptionRequest` 对象，包含 `novelId`, `optionId`, `selectedConfigId` 和可选的 `regenerateHint`。
        * 同样需要使用 `SseClient`。
        * 返回 `Stream<OutlineGenerationChunk>`。
        * **注意:** 后端会保留该 `optionId` 对应的原始上下文范围参数，前端无需重新传递 `startChapterId` 和 `endChapterId`。
    * `POST /api/novels/{novelId}/chapters/add-from-outline`:
        * **请求参数:** 构建 `AddChapterFromOutlineRequest` 对象，包含 `novelId`, `selectedOutlineTitle`, `selectedOutlineContent`, 以及可选的 `precedingChapterId`（插入位置）。如果不指定 `precedingChapterId`，则默认插入到小说末尾。
        * 普通的 POST 请求。
        * 返回成功/失败状态，或新创建的 Chapter 对象。
* 确保 Repository 层处理了网络错误和 API 返回的业务错误，并转换为领域层或 BLoC 层可以理解的异常或状态。
* 需要方法获取指定 `novelId` 的章节列表（可能已存在于 `NovelRepository` 或 `EditorBloc`）。
* 需要方法获取用户配置的 AI 模型列表（可能已存在于 `UserAIModelConfigRepository` 或 `AiConfigBloc`）。

### 4.5 数据模型 (Dart)

* 创建 Dart 类来对应后端定义的 DTO:
    * `GenerateNextOutlinesRequest`:
        ```dart
        class GenerateNextOutlinesRequest {
          final String novelId;
          final String? startChapterId; // 上下文开始章节ID (可选, null表示从第一章开始)
          final String? endChapterId;   // 上下文结束章节ID (可选, null表示到最后一章)
          final int numberOfOptions;
          final String? authorGuidance;
          final List<String> selectedConfigIds;
          final String? regenerateHint;  // 用于全局重新生成时的额外提示 (可选)
          
          GenerateNextOutlinesRequest({
            required this.novelId,
            this.startChapterId,
            this.endChapterId,
            required this.numberOfOptions,
            this.authorGuidance,
            required this.selectedConfigIds,
            this.regenerateHint,
          });
          
          Map<String, dynamic> toJson() => {
            // JSON 序列化逻辑
          };
        }
        ```
    * `OutlineGenerationChunk`:
        ```dart
        class OutlineGenerationChunk {
          final String optionId;         // 唯一标识该选项的ID
          final String? optionTitle;     // AI 生成的该选项的短标题 (可能为null)
          final String textChunk;        // 大纲内容的文本片段
          final bool isFinalChunk;       // 是否是该选项的最后一个片段
          final String? error;           // 错误信息 (如果有)
          
          OutlineGenerationChunk({
            required this.optionId,
            this.optionTitle,
            required this.textChunk,
            required this.isFinalChunk,
            this.error,
          });
          
          factory OutlineGenerationChunk.fromJson(Map<String, dynamic> json) {
            // JSON 反序列化逻辑
          }
        }
        ```
    * `RegenerateOutlineOptionRequest`:
        ```dart
        class RegenerateOutlineOptionRequest {
          final String novelId;
          final String optionId;        // 要重新生成的剧情选项的ID
          final String selectedConfigId; // 用于重新生成的 AI 模型配置 ID
          final String? regenerateHint;  // 针对本次重新生成的额外提示 (可选)
          
          RegenerateOutlineOptionRequest({
            required this.novelId,
            required this.optionId,
            required this.selectedConfigId,
            this.regenerateHint,
          });
          
          Map<String, dynamic> toJson() => {
            // JSON 序列化逻辑
          };
        }
        ```
    * `AddChapterFromOutlineRequest`:
        ```dart
        class AddChapterFromOutlineRequest {
          final String novelId;
          final String selectedOutlineTitle;   // 选中的 AI 生成的标题，用作新章节标题
          final String selectedOutlineContent; // 选中的大纲文本，用作新场景摘要
          final String? precedingChapterId;    // 插入位置：指定新章节应插入在此章节ID之后 (可选)
          
          AddChapterFromOutlineRequest({
            required this.novelId,
            required this.selectedOutlineTitle,
            required this.selectedOutlineContent,
            this.precedingChapterId,
          });
          
          Map<String, dynamic> toJson() => {
            // JSON 序列化逻辑
          };
        }
        ```
* 这些模型应包含 `fromJson` 和 `toJson` 方法（或使用 `json_serializable`）。

### 4.6 标题和内容处理

* **后端标题提取机制:**
    * 后端会尝试从 AI 生成的文本中提取以 `TITLE:` 开头的标题，以及 `CONTENT:` 之后的内容。
    * 如果后端无法提取出标题（例如，当 AI 没有按照预期格式返回内容时），会使用默认标题或生成一个描述性标题。
* **前端标题处理:**
    * 前端应确保能够正确显示后端提取并通过 `OutlineGenerationChunk.optionTitle` 字段传递的标题。
    * 在标题还未收到之前（例如，在 SSE 连接建立后的最初几个 chunk），可显示"生成中..."或类似的占位符。
    * 一旦收到包含 `optionTitle` 的 chunk，应立即更新 UI 显示。
* **前端内容处理:**
    * 收到的 `textChunk` 应以打字机效果追加显示，不需要尝试解析或提取标题。
    * 如果 `textChunk` 中包含 `TITLE:` 或 `CONTENT:` 前缀，前端可以选择保留或去除这些前缀（由于后端已经尝试提取，通常应该不会出现）。

## 5. 非功能性需求

* **响应式 UI:** 界面应能流畅地响应状态变化（加载、流式文本更新、错误提示）。
* **性能:**
    * 打字机效果应平滑，不阻塞 UI 线程。
    * BLoC 状态更新应高效，避免不必要的 UI 重建。
    * 列表（章节、模型、结果卡片）的构建应使用懒加载或虚拟化技术（如 `ListView.builder`, `GridView.builder`）。
* **错误处理:**
    * 向用户清晰地展示网络错误、API 错误、SSE 连接错误。
    * 提供重试机制（如果适用）。
    * 优雅地处理单个选项生成失败的情况，不影响其他选项。
* **代码质量:**
    * 遵循 Flutter 和 Dart 的最佳实践。
    * 代码结构清晰，模块化（Screen, BLoC, Repository, Widgets 分离）。
    * 添加必要的单元测试和 Widget 测试。
* **UI/UX 一致性:**
    * 遵循项目现有的设计规范、主题 (`AppTheme`) 和文本样式 (`TextStyles`)。
    * 交互行为应符合用户预期。

## 6. 技术选型建议

* **语言:** Dart
* **框架:** Flutter
* **状态管理:** flutter_bloc
* **HTTP & SSE Client:** http, sse_client (或自定义实现)
* **JSON序列化:** json_serializable
* **响应式布局:** `LayoutBuilder`, `GridView` 或 `flutter_staggered_grid_view`
* **下拉框:** `DropdownButtonFormField` 或自定义组件
* **加载指示器:** `CircularProgressIndicator`, `LinearProgressIndicator`
* **打字机效果:** 自定义 Widget 或 `animated_text_kit`

## 7. 开放问题与待讨论

* 导航入口的具体位置？（`EditorAppBar`? 侧边栏?）
* 保存选中大纲后，是否需要自动导航到新创建的章节/场景的编辑界面？
* 章节和 AI 模型列表的获取方式？（复用现有 BLoC/Repository 还是新建？）
* 打字机效果的具体实现方案？
* 错误提示的具体样式和交互？
* **已明确:** 新创建场景的默认标题为"场景 1"。

