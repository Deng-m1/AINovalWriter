# 前端需求文档 - 剧情推演 (Next Outline Generation) 功能

**版本:** 1.0
**日期:** 2025年4月20日
**基于后端需求:** `next_outline_backend_reqs_v1` (v1.3)
**基于前端原型:** `next_outline_prototype_v3`

## 1. 功能概述

在 Flutter 应用中新增“剧情推演”功能模块。该模块允许用户基于当前打开的小说，选择一段章节范围作为上下文，调用后端 AI 服务生成多个后续剧情大纲选项（包含标题和摘要）。用户可以浏览这些选项，对不满意的选项进行单独的模型选择和重新生成，最终选择一个满意的大纲，并将其保存为小说的一个新章节及其首个场景。

## 2. 目标用户

小说作者、编剧。

## 3. 功能目标

* 提供直观易用的界面，让用户可以方便地配置生成参数、浏览结果、进行交互。
* 实现流畅的流式数据显示（打字机效果），提升用户体验。
* 有效管理功能状态（加载、错误、结果显示、单项刷新等）。
* 与现有 Flutter 应用（导航、主题、状态管理、API 服务）无缝集成。

## 4. 功能性需求

### 4.1 导航集成

* 在主要的导航区域（例如 `EditorScreen` 的 `EditorAppBar` 或应用的侧边栏/底部导航栏，需根据最终设计定夺）添加一个新的导航入口，标签为“剧情推演”。
* 点击该入口后，应导航到新的 `NextOutlineScreen` 页面，并传递当前正在编辑的小说的 `novelId`。

### 4.2 剧情推演屏幕 (`NextOutlineScreen`)

* **屏幕结构:**
    * **AppBar:** 显示页面标题，例如“剧情推演 - [小说标题]”。包含返回按钮。
    * **主内容区 (ScrollView):**
        * **配置面板 (Widget A):** 对应原型图顶部的配置区域。
        * **结果区域 (Widget B):** 对应原型图下方的结果展示区域。

* **Widget A: 配置面板 (`OutlineGenerationConfigCard`)**
    * UI 样式需与原型图一致 (圆角卡片、内边距等)。
    * **上下文章节选择:**
        * 提供两个下拉选择器 (`DropdownButtonFormField` 或自定义下拉组件):
            * “上下文开始章节” (`startChapterSelect`)
            * “上下文结束章节” (`endChapterSelect`)
        * 下拉框选项应动态加载当前 `novelId` 对应的章节列表（章节 ID 和标题）。此数据需从 `EditorBloc` 或通过 `NovelRepository` 获取。
        * 需处理默认选中项（例如，开始章节默认第一章，结束章节默认最后一章）。
        * 需要校验：结束章节不能早于开始章节。
    * **生成选项数量:**
        * 提供下拉选择器 (`numOptionsSelect`) 让用户选择希望生成的剧情选项数量（例如 2-5）。
    * **作者偏好/引导:**
        * 提供多行文本输入框 (`TextField`) 让用户输入可选的引导信息 (`authorGuidanceTextarea`)。
    * **生成按钮:**
        * 一个醒目的按钮 (`ElevatedButton`)，标签为“生成剧情大纲”。
        * 点击后，收集所有配置参数，触发 `NextOutlineBloc` 发起初始生成事件。
        * 按钮在生成过程中应显示加载状态或禁用。

* **Widget B: 结果区域 (`OutlineResultsArea`)**
    * **标题:** 显示“生成结果”文本。
    * **状态显示:**
        * **全局加载状态 (`LoadingIndicator`):** 在调用初始生成或全局重新生成 API 时显示（对应原型 `loading-state`）。
        * **空状态 (`EmptyStatePlaceholder`):** 在首次进入或没有生成结果时显示（对应原型 `empty-state`）。
        * **错误状态:** 当 API 调用失败或 SSE 连接错误时，显示用户友好的错误提示信息和可能的重试按钮。
    * **结果网格 (`ResultsGrid`)**:
        * 使用响应式布局（如 `GridView.builder` 配合 `LayoutBuilder` 或 `flutter_staggered_grid_view`）来展示结果卡片，适配不同屏幕尺寸（对应原型 `results-grid`）。
        * 根据 `NextOutlineBloc` 的状态动态构建卡片列表。
    * **结果卡片 (`ResultCard`)**:
        * **唯一标识:** 存储 `optionId`。
        * **加载遮罩:** 包含一个覆盖层，在单独重新生成该卡片时显示加载动画（对应原型 `card-loading-overlay`）。
        * **标题显示:** 显示从 SSE 收到的 `optionTitle`。
        * **内容显示:**
            * 流式显示从 SSE 收到的 `textChunk`。
            * **实现打字机效果:** 可以使用现有 `ai_stream_generation_display.dart` 或类似逻辑，或者引入 `animated_text_kit` 等库。
        * **底部操作区:**
            * **模型选择下拉框 (`regenerateModelSelect`):**
                * 显示用户已配置的 AI 模型列表 (`UserAIModelConfig`)。此列表需从 `AiConfigBloc` 或 `UserAIModelConfigRepository` 获取。
                * 允许用户为该卡片的下一次重新生成选择不同的模型。
            * **单项刷新按钮 (`regenerateSingleButton`):**
                * 一个带刷新图标的按钮 (`IconButton` 或 `TextButton.icon`)。
                * 点击后，获取当前卡片的 `optionId` 和模型下拉框中选中的 `configId`，触发 `NextOutlineBloc` 发起单个选项重新生成事件。
            * **选择大纲按钮 (`selectOutlineButton`):**
                * 根据当前卡片是否被选中，显示不同样式（如原型所示，选中时高亮）。
                * 点击后，更新 `NextOutlineBloc` 中的选中状态，并触发保存操作（或提供单独的保存按钮）。
    * **全局操作按钮 (`GlobalActionButtons`)**:
        * **重新生成(全部)按钮:** 点击后触发 `NextOutlineBloc` 发起全局重新生成事件。
        * **提示输入框:** `TextField` 用于输入全局提示。
        * **提示并重试(全部)按钮:** 点击后，获取提示内容，触发 `NextOutlineBloc` 发起带提示的全局重新生成事件。

### 4.3 状态管理 (`NextOutlineBloc`)

* **职责:** 管理 `NextOutlineScreen` 的状态，处理用户交互事件，与后端 API 交互。
* **依赖:** `NovelRepository`, `UserAIModelConfigRepository` (或对应 Bloc), `SseClient`。
* **状态 (`NextOutlineState`):**
    * `novelId`: 当前小说 ID。
    * `chapters`: 小说章节列表 (用于填充下拉框)。
    * `aiModelConfigs`: 可用 AI 模型配置列表 (用于填充下拉框)。
    * `generationStatus`: 当前状态枚举 (e.g., `initial`, `loadingChapters`, `loadingModels`, `generatingInitial`, `generatingSingle`, `idle`, `error`, `saving`)。
    * `outlineOptions`: `List<OutlineOptionState>` - 当前显示的剧情选项列表。
    * `selectedOptionId`: 当前用户选中的剧情选项 ID (可选)。
    * `errorMessage`: 错误信息。
* **`OutlineOptionState` (嵌套状态):**
    * `optionId`: 唯一标识符。
    * `title`: AI 生成的标题 (可能逐步更新)。
    * `contentStreamController`: 用于接收和缓冲 SSE 发来的 `textChunk`。
    * `fullContent`: 拼接完成的完整内容。
    * `isGenerating`: 是否正在单独重新生成此选项。
    * `error`: 此选项相关的错误信息。
* **事件 (`NextOutlineEvent`):**
    * `LoadData(String novelId)`: 加载章节和模型列表。
    * `GenerateInitialRequested(GenerateNextOutlinesRequest request)`: 请求初始生成。
    * `RegenerateSingleRequested(RegenerateOutlineOptionRequest request)`: 请求重新生成单个选项。
    * `GlobalRegenerateRequested()`: 请求全局重新生成。
    * `GlobalRegenerateWithHintRequested(String hint)`: 请求带提示的全局重新生成。
    * `_SseChunkReceived(OutlineGenerationChunk chunk)`: (内部事件) 处理收到的 SSE 数据块。
    * `_SseErrorOccurred(String optionId, String error)`: (内部事件) 处理 SSE 错误。
    * `_SseConnectionClosed()`: (内部事件) 处理 SSE 连接关闭。
    * `OptionSelected(String optionId)`: 用户选择了一个选项。
    * `SaveSelectedOutlineRequested(AddChapterFromOutlineRequest request)`: 请求保存选中的大纲。
* **核心逻辑:**
    * 初始化时加载章节和模型数据。
    * 处理生成请求事件，调用相应的 Repository 方法发起 API 请求。
    * **管理 SSE 连接:** 对于 `generate-next-outlines` 和 `regenerate-outline-option` API，建立 SSE 连接，监听事件。
    * **处理 SSE 数据:** 解析 `OutlineGenerationChunk`，根据 `optionId` 找到对应的 `OutlineOptionState`，更新其 `title` 和 `contentStreamController`。使用 `emit` 更新 BLoC 状态以驱动 UI 刷新。
    * 处理 SSE 错误和连接关闭事件，更新状态。
    * 管理卡片的选中状态。
    * 处理保存请求，调用 Repository 方法，更新状态（显示加载、成功或失败）。

### 4.4 API 集成 (`NovelRepository` / `NextOutlineRepository`)

* 需要添加或修改 Repository 层的方法来调用以下后端 API:
    * `POST /api/novels/{novelId}/ai/generate-next-outlines`:
        * 需要使用 `SseClient` 来处理流式响应。
        * 返回一个 `Stream<OutlineGenerationChunk>` 或类似结构给 BLoC。
    * `POST /api/novels/{novelId}/ai/regenerate-outline-option`:
        * 同样需要使用 `SseClient`。
        * 返回 `Stream<OutlineGenerationChunk>`。
    * `POST /api/novels/{novelId}/chapters/add-from-outline`:
        * 普通的 POST 请求。
        * 返回成功/失败状态，或新创建的 Chapter 对象。
* 确保 Repository 层处理了网络错误和 API 返回的业务错误，并转换为领域层或 BLoC 层可以理解的异常或状态。
* 需要方法获取指定 `novelId` 的章节列表（可能已存在于 `NovelRepository` 或 `EditorBloc`）。
* 需要方法获取用户配置的 AI 模型列表（可能已存在于 `UserAIModelConfigRepository` 或 `AiConfigBloc`）。

### 4.5 数据模型 (Dart)

* 创建 Dart 类来对应后端定义的 DTO:
    * `GenerateNextOutlinesRequest`
    * `OutlineGenerationChunk` (包含 `optionId`, `optionTitle`, `textChunk`, `isFinalChunk`, `error`)
    * `RegenerateOutlineOptionRequest`
    * `AddChapterFromOutlineRequest`
* 这些模型应包含 `fromJson` 和 `toJson` 方法（或使用 `json_serializable`）。

## 5. 非功能性需求

* **响应式 UI:** 界面应能流畅地响应状态变化（加载、流式文本更新、错误提示）。
* **性能:**
    * 打字机效果应平滑，不阻塞 UI 线程。
    * BLoC 状态更新应高效，避免不必要的 UI 重建。
    * 列表（章节、模型、结果卡片）的构建应使用懒加载或虚拟化技术（如 `ListView.builder`, `GridView.builder`）。
* **错误处理:**
    * 向用户清晰地展示网络错误、API 错误、SSE 连接错误。
    * 提供重试机制（如果适用）。
    * 优雅地处理单个选项生成失败的情况，不影响其他选项。
* **代码质量:**
    * 遵循 Flutter 和 Dart 的最佳实践。
    * 代码结构清晰，模块化（Screen, BLoC, Repository, Widgets 分离）。
    * 添加必要的单元测试和 Widget 测试。
* **UI/UX 一致性:**
    * 遵循项目现有的设计规范、主题 (`AppTheme`) 和文本样式 (`TextStyles`)。
    * 交互行为应符合用户预期。

## 6. 技术选型建议

* **语言:** Dart
* **框架:** Flutter
* **状态管理:** flutter_bloc
* **HTTP & SSE Client:** http, sse_client (或自定义实现)
* **JSON序列化:** json_serializable
* **响应式布局:** `LayoutBuilder`, `GridView` 或 `flutter_staggered_grid_view`
* **下拉框:** `DropdownButtonFormField` 或自定义组件
* **加载指示器:** `CircularProgressIndicator`, `LinearProgressIndicator`
* **打字机效果:** 自定义 Widget 或 `animated_text_kit`

## 7. 开放问题与待讨论

* 导航入口的具体位置？（`EditorAppBar`? 侧边栏?）
* 保存选中大纲后，是否需要自动导航到新创建的章节/场景的编辑界面？
* 章节和 AI 模型列表的获取方式？（复用现有 BLoC/Repository 还是新建？）
* 打字机效果的具体实现方案？
* 错误提示的具体样式和交互？
* 新创建场景的默认标题如何确定？

