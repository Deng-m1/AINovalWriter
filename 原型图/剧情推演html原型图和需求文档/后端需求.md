# 后端需求文档 - 剧情推演 (Next Outline Generation) 功能

**版本:** 1.3 (修订版)
**日期:** 2025年4月20日
**负责人:** [您的名字/团队]
**变更记录:**
* v1.1: 增加对单个剧情选项进行独立重新生成的功能和对应 API。
* v1.2: 根据用户决策更新上下文范围定义、AI 生成标题要求、大纲保存逻辑，并明确单个选项重新生成的上下文策略。
* v1.3: 将上下文范围定义从单一目标点修改为用户指定的 **开始章节** 和 **结束章节**。

## 1. 功能概述

“剧情推演”功能旨在利用 AI 大模型，根据用户当前小说的既有情节（**限定在用户指定的章节范围内**）、设定和用户偏好，生成多个可能的后续剧情大纲（以场景摘要的形式呈现，并附带一个简短标题），供用户选择，以辅助创作构思。用户可以在一个专门的界面（对应前端原型 `next_outline_prototype.html`）**选择上下文的起止章节**，配置生成参数，触发此功能，浏览 AI 生成的多个剧情走向，针对不满意的选项进行单独重新生成（可更换模型），并选择最满意的一个将其作为一个新的章节（使用 AI 生成的标题）和其中的第一个场景（使用大纲作为摘要）整合回小说的整体结构中。

## 2. 目标用户

小说作者、编剧等需要进行情节构思和推进的用户。

## 3. 功能目标

* **激发灵感:** 提供多种剧情可能性，打破创作瓶颈。
* **提升效率:** 快速生成多个剧情方向，节省作者构思时间。
* **保持一致性:** AI 生成的大纲需尽可能贴合现有小说的设定和 **指定章节范围** 内的情节。
* **个性化:** 允许用户通过选择上下文范围、提示词和偏好设置引导 AI 生成方向，并支持对单个不满意的结果进行细化调整。
* **高性能:** 支持并发请求多个 AI 模型，并以流式响应，提供流畅的用户体验。

## 4. 功能性需求

### 4.1 核心流程

1.  **前端触发 (初始生成):** 用户在“剧情推演”页面配置选项（**选择上下文开始章节ID和结束章节ID**、生成数量、作者偏好等），选择一个或多个 AI 模型配置，点击“生成剧情大纲”按钮。
2.  **后端接收请求 (初始生成):** 后端接收到包含小说 ID、**上下文起止章节ID**、生成参数、用户偏好、所选 AI 配置列表的请求。 (调用 API 4.2.1)
3.  **上下文准备:**
    * 根据小说 ID 从数据库（MongoDB）中检索相关的 `Novel` 信息（包括基本设定、人物等）。
    * **上下文范围定义:** 根据请求中提供的 `startChapterId` 和 `endChapterId`，从数据库中查询并提取 **该范围内所有章节** 的所有 `Scene` 的摘要 (`summary` 字段，如果存在且非空) 作为核心上下文。
        * 如果 `startChapterId` 为 null 或空，则从第一章开始。
        * 如果 `endChapterId` 为 null 或空，则到最后一章结束。
        * 需要进行校验，确保 `endChapterId` 对应的章节不早于 `startChapterId` 对应的章节。
    * 聚合小说设定、人物信息、以及提取的场景摘要，形成基础上下文信息。
4.  **Prompt 构建 (初始生成):**
    * 根据 `AIFeatureType.NEXT_OUTLINE_GENERATION` (需要新增此类型) 查找用户自定义的 `UserPromptTemplate` 或系统默认的 `PromptTemplate`。
    * 结合基础上下文信息、用户输入的“作者偏好/引导” (`authorGuidance`) 以及 Prompt 模板，为每个选定的 AI 模型构建具体的请求 Prompt。Prompt 应明确指示 AI 同时生成剧情大纲和一个简短的、概括性的标题/标签。
5.  **并发 AI 请求 (初始生成):**
    * 利用配置的虚拟线程池 (`VirtualThreadTaskExecutor`)，为用户选择的每个 AI 模型配置 (`UserAIModelConfig`) 并发地发起 AI 生成请求。
    * 请求的目标是让每个 AI 模型根据提供的 Prompt 生成一个剧情大纲（场景摘要）以及一个对应的短标题。每个请求应期望返回一个独立的剧情选项，并分配一个唯一的 `optionId`。
    * 请求需支持流式响应 (Streaming)。
6.  **流式响应处理 (初始生成):**
    * 后端通过 SSE (Server-Sent Events) 将每个 AI 模型生成的剧情大纲选项（包括标题和大纲内容）实时推送给前端。
    * 每个推送的事件应包含 `optionId`（用于唯一标识该选项）、生成的短标题 (`optionTitle`) 和生成的文本片段 (`textChunk`)。标题可以在第一个 chunk 中发送，或者作为一个单独的 SSE 事件发送。
7.  **前端展示:** 前端接收 SSE 事件，在对应的竖栏中以打字机效果展示生成的剧情大纲及其标题。每个选项卡片下方应包含重新生成该选项的控件（如刷新按钮、可选的模型列表）。
8.  **用户交互 (重新生成/提示):**
    * **重新生成 (全局):** 用户点击全局的“重新生成”按钮，前端发送与初始请求类似的 API 请求 (调用 API 4.2.1，**使用相同的起止章节ID**)，后端重复步骤 3-6，生成一套全新的选项。
    * **提供提示并重试 (全局):** 用户输入全局提示信息，点击“提供提示并重试”按钮，前端将新的提示信息连同原始请求参数（**包括相同的起止章节ID**）一起发送给后端 (调用 API 4.2.1，在 `regenerateHint` 字段传入提示)，后端在步骤 4 构建 Prompt 时纳入考虑，然后重复步骤 5-6，生成一套全新的选项。
    * **重新生成 (单个选项):** 用户在某个剧情选项卡片上点击“刷新”按钮，或选择了新的 AI 模型后触发重新生成。前端发送 **针对该特定选项** 的重新生成请求 (调用 API 4.2.2)，需要携带 `novelId`、要重新生成的 `optionId`、以及用户新选择的 `UserAIModelConfig` ID（如果更换了模型）和可能的额外提示。
9.  **后端处理 (单个选项重新生成):**
    * 后端接收到单个选项重新生成的请求 (API 4.2.2)。
    * **获取原始上下文:** 需要获取该 `optionId` 对应的 **初始生成请求所使用的上下文**（基于原始的 `startChapterId` 和 `endChapterId`）。这可以通过缓存或重新查询实现。
    * **构建 Prompt:** 基于获取到的原始上下文、用户提供的 `regenerateHint`（如果有）以及新选择的 `UserAIModelConfig` ID，构建新的 Prompt。上下文 (`authorGuidance` 等) 继承自初始请求，在此基础上进行优化。
    * 发起 **单个** AI 请求 (步骤 5 的简化版)，同样要求生成大纲和短标题。
    * 通过 SSE 流式返回 **该 `optionId`** 的新内容（包括新标题和新大纲）(步骤 6 的简化版)。
10. **用户选择大纲:** 用户在前端选择一个满意的剧情大纲选项。
11. **保存选中大纲:** 前端将被选中的 **大纲标题** 和 **大纲内容** 发送给后端 (调用 API 4.2.3)。后端执行以下操作：
    * **创建新章节:** 在 `Novel` 结构中，紧随 **上下文结束章节 (`endChapterId`)** 之后（或根据 `precedingChapterId` 参数指定的位置），创建一个新的章节，章节标题使用 AI 生成并由用户选中的 `selectedOutlineTitle`。
    * **创建新场景:** 在新创建的章节下，创建一个新的 `Scene` 对象。
    * **填充场景摘要:** 将选中的大纲内容 (`selectedOutlineContent`) 填充到新 `Scene` 的 `summary` 字段。
    * **设置场景标题:** 新 `Scene` 的标题可以默认为 "场景 1" 或复用章节标题，或留空由用户后续编辑 (需要明确)。
    * **设置场景状态:** 可选地设置一个初始状态（如 "待续写"）。

### 4.2 API 设计

#### 4.2.1 生成剧情大纲 (初始生成 / 全局重新生成) (SSE)

* **Endpoint:** `POST /api/novels/{novelId}/ai/generate-next-outlines`
* **Request Body:** `GenerateNextOutlinesRequest` DTO (**修改上下文参数**)
    ```java
    // 包: com.ainovel.server.web.dto
    @Data
    public class GenerateNextOutlinesRequest {
        @NotBlank
        private String novelId;
        // @Deprecated private String targetChapterId; // 废弃
        // @Deprecated private String targetSceneId; // 废弃
        private String startChapterId; // 新增：上下文开始章节ID (可选, null表示从第一章开始)
        private String endChapterId;   // 新增：上下文结束章节ID (可选, null表示到最后一章)
        @NotNull @Min(1)
        private Integer numberOfOptions;
        private String authorGuidance;
        @NotEmpty
        private List<String> selectedConfigIds;
        private String regenerateHint; // 用于全局重新生成时的额外提示 (可选)
        // 注意：需要添加校验逻辑确保 endChapterId 不早于 startChapterId (如果两者都非null)
    }
    ```
* **Response:** `Flux<ServerSentEvent<OutlineGenerationChunk>>`
    * `OutlineGenerationChunk` DTO (同 v1.2)
        ```java
        // 包: com.ainovel.server.web.dto
        @Data
        @NoArgsConstructor
        @AllArgsConstructor
        public class OutlineGenerationChunk {
            private String optionId;
            private String optionTitle; // AI 生成的该选项的短标题/标签
            private String textChunk;   // 大纲内容的文本片段
            private boolean isFinalChunk;
            private String error;
        }
        ```
    * SSE 事件格式 (同 v1.2)

#### 4.2.2 重新生成单个剧情大纲 (SSE)

* **Endpoint:** `POST /api/novels/{novelId}/ai/regenerate-outline-option`
* **Request Body:** `RegenerateOutlineOptionRequest` DTO (无变更)
    ```java
    // 包: com.ainovel.server.web.dto
    @Data
    public class RegenerateOutlineOptionRequest {
        @NotBlank
        private String novelId;
        @NotBlank
        private String optionId; // 要重新生成的剧情选项的ID
        @NotBlank
        private String selectedConfigId; // 用于重新生成的 AI 模型配置 ID
        private String regenerateHint; // 针对本次重新生成的额外提示 (可选)
        // 注意：此请求不直接传递上下文范围，后端服务需根据 optionId 获取原始生成请求的上下文范围。
    }
    ```
* **Response:** `Flux<ServerSentEvent<OutlineGenerationChunk>>` (同 v1.2, 包含 `optionTitle`)

#### 4.2.3 保存选中的大纲

* **Endpoint:** `POST /api/novels/{novelId}/chapters/add-from-outline` (路径不变)
* **Request Body:** `AddChapterFromOutlineRequest` DTO (**修改插入位置参数**)
    ```java
    // 包: com.ainovel.server.web.dto
    @Data
    public class AddChapterFromOutlineRequest {
        @NotBlank
        private String novelId;
        @NotBlank
        private String selectedOutlineTitle; // 选中的 AI 生成的标题，用作新章节标题
        @NotBlank
        private String selectedOutlineContent; // 选中的大纲文本，用作新场景摘要
        private String precedingChapterId; // 插入位置：指定新章节应插入在此章节ID之后 (可选, 默认为小说当前末尾)
    }
    ```
* **Response:** `Mono<Chapter>` or `Mono<Void>` (同 v1.2)

### 4.3 数据模型变更

(同 v1.2)
* **`AIFeatureType` (Enum):** 新增 `NEXT_OUTLINE_GENERATION` 枚举值。
* **`PromptTemplate` / `UserPromptTemplate`:** 需要为此功能设计和添加默认及用户可自定义的模板。模板应包含必要的占位符，如 `{novel_setting}`, `{characters}`, `{previous_summaries}`, `{author_guidance}`, `{regenerate_hint}` 等。需要明确要求 AI 输出标题和大纲。
* **`Scene`:** 考虑是否需要新增字段来标记该场景是由“剧情推演”功能生成的，或者其初始状态。
* **`Chapter`:** (无直接变更，但会通过 API 创建新实例)

### 4.4 依赖与集成

* **`NovelService`:** 用于获取小说信息、设定、章节和场景列表。需要扩展以支持根据 **`startChapterId` 和 `endChapterId`** 获取指定范围内的场景摘要。需要提供方法来添加新的 `Chapter` (包含一个初始 `Scene`) 到指定位置 (根据 `precedingChapterId` 或默认末尾)。
* **`SceneService`:** 可能需要提供更灵活的场景查询方法。
* **`NovelAIService` / `AIService`:** 核心实现逻辑所在地。需要协调 Prompt 构建 (确保请求标题生成)、并发 AI 请求、流式响应处理、以及处理单个选项重新生成的逻辑 (**需要实现获取原始上下文的机制**)。
* **`UserAIModelConfigService`:** 获取用户配置的 AI 模型信息。
* **`PromptTemplateService` / `UserPromptService`:** 获取用于生成 Prompt 的模板。
* **`VirtualThreadConfig`:** 确保虚拟线程池已配置并可注入使用。
* **错误处理:** 继承现有项目的全局异常处理机制，并通过 SSE 返回明确的错误信息。

## 5. 非功能性需求

(同 v1.2)
* **性能:** AI 请求并发执行，使用虚拟线程。SSE 连接管理高效。数据库查询优化。
* **可扩展性:** 易于接入新 AI 模型和管理 Prompt 模板。
* **可靠性:** 对 AI 服务失败有容错处理。
* **可配置性:** 默认 Prompt、线程池参数等可配置。
* **安全性:** API 认证授权，输入清理，内容安全过滤。

## 6. 技术选型建议

(同 v1.2)
* **框架:** Spring Boot (WebFlux 用于 SSE 端点)
* **数据库:** MongoDB
* **并发:** Java Virtual Threads (`VirtualThreadTaskExecutor`)
* **AI 交互:** 沿用现有的 `AIModelProvider` 抽象和 LangChain4j (如果已使用)。
* **流式响应:** Server-Sent Events (SSE)

## 7. 里程碑与计划 (示例)

* **Sprint X:**
    * 完成 API 设计和 DTO 定义 (**更新上下文参数**)。
    * 实现基础的上下文获取 (**基于起止章节**) 和 Prompt 构建逻辑 (加入标题生成要求)。
    * 集成 `NovelService` 和 `PromptTemplateService`。
* **Sprint X+1:**
    * 实现并发 AI 请求逻辑（初始生成，含标题）。
    * 实现 SSE 流式响应 (初始生成，含标题)。
    * 实现单个选项重新生成的 API 和逻辑 (**包括获取原始上下文**)。
    * 完成错误处理机制。
* **Sprint X+2:**
    * 实现保存选中大纲的功能 (创建新章节和场景，**处理插入位置**)。
    * 集成 `UserAIModelConfigService`。
    * 编写单元测试和集成测试 (覆盖新 API 和逻辑)。
    * 与前端联调 (包括起止章节选择、单项刷新和保存新章节功能)。

## 8. 开放问题与待讨论

* **(已明确)** 上下文范围定义: 用户通过 `startChapterId` 和 `endChapterId` 指定范围 (包含边界)。
* 上下文的最大长度限制是多少？如何处理超长上下文？（截断？摘要的摘要？）
* **(部分明确)** 保存大纲时，新创建的章节标题使用 AI 生成的标题。但新章节下的第一个场景的 **场景标题** 如何确定？(默认为 "场景 1" 或复用章节标题？还是留空？)
* **(已明确)** 单个选项重新生成时，其上下文 (`authorGuidance` 等) 强制继承自初始请求，在此基础上进行优化。
* **(已明确)** 需要 AI 为每个生成的剧情选项提供一个简短的标题或标签。

