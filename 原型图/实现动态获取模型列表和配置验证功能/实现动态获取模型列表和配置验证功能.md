# AI 模型配置增强：动态模型列表与配置验证需求文档

## 1. 简介

本文档旨在明确增强 AI 模型配置功能的需求，允许系统根据不同 AI 提供商的能力动态获取模型列表，并在用户配置 API Key 后进行验证，优化用户体验并确保配置的有效性。

## 2. 背景

当前系统在添加模型配置时，主要依赖后端预定义的或通过简单接口获取的默认模型列表。部分 AI 提供商（如 OpenAI, Anthropic）需要有效的 API Key 才能获取其完整的模型列表，而另一些（如 OpenRouter）则不需要。用户在填写 API Key 后，缺乏即时的验证机制，也无法看到基于该 Key 可用的全部模型。

**目标：**

1.  根据模型提供商的不同能力（无需 Key、需要 Key、不支持 API 列表）动态获取模型列表。
2.  在用户输入 API Key 后，提供即时验证机制。
3.  验证成功后，如果提供商支持，则使用该 Key 重新获取并刷新模型列表。
4.  在用户配置列表中，明确标识已验证成功的配置。
5.  防止用户添加重复的、已验证成功的模型配置。

## 3. 后端需求 (Java Spring Boot)

### 3.1. 数据模型与接口 (`AIModelProvider.java`)

1.  **新增 `ModelListingCapability` 枚举:**
    *   定义一个枚举来标识提供商获取模型列表的能力。
    *   **文件:** `com.ainovel.server.service.ai.ModelListingCapability.java` (或放在 `AIModelProvider` 内部)
    *   **定义:**
        ```java
        public enum ModelListingCapability {
            NO_LISTING,          // 不支持通过 API 获取模型列表
            LISTING_WITHOUT_KEY, // 无需 API Key 即可获取列表
            LISTING_WITH_KEY,    // 需要 API Key 才能获取列表
            LISTING_WITH_OR_WITHOUT_KEY // 支持无 Key 获取默认列表，有 Key 获取完整列表 (可选实现)
        }
        ```

2.  **`AIModelProvider` 接口添加方法:**
    *   添加 `getModelListingCapability()` 方法，返回上述枚举。
    *   **方法签名:**
        ```java
        /**
         * 获取此提供商的模型列表功能。
         * @return 模型列表功能枚举
         */
        ModelListingCapability getModelListingCapability();
        ```

3.  **所有 `AIModelProvider` 实现类:**
    *   必须实现 `getModelListingCapability()` 方法，并根据各自平台的实际情况返回正确的枚举值。
    *   **示例 (`OpenAILangChain4jModelProvider.java`):**
        ```java
        @Override
        public ModelListingCapability getModelListingCapability() {
            return ModelListingCapability.LISTING_WITH_KEY;
        }
        ```
    *   **示例 (`OpenRouterLangChain4jModelProvider.java`):**
        ```java
        @Override
        public ModelListingCapability getModelListingCapability() {
            return ModelListingCapability.LISTING_WITHOUT_KEY;
        }
        ```
    *   确保 `listModels()` 和 `listModelsWithApiKey()` 的行为与声明的 `Capability` 一致。
        *   对于 `LISTING_WITH_KEY`，`listModels()` 应返回空或默认/占位符模型，`listModelsWithApiKey()` 执行实际 API 调用。
        *   对于 `LISTING_WITHOUT_KEY`，`listModels()` 执行实际 API 调用。

### 3.2. 服务层 (`AIService.java`)

1.  **提供获取 Provider 实例的方法:**
    *   需要一个方法，能根据提供商名称字符串获取对应的 `AIModelProvider` 实例，以便 Controller 调用 `getModelListingCapability()`。
    *   **方法示例:** `Mono<AIModelProvider> getProvider(String providerName)`

### 3.3. 控制器 (`ModelInfoController.java`)

1.  **新增 Endpoint - 获取列表能力:**
    *   **路径:** `GET /api/models/providers/{provider}/capability`
    *   **参数:** `provider` (路径参数) - 提供商名称 (e.g., "openai")
    *   **成功响应 (200 OK):**
        ```json
        // Body: ModelListingCapability 枚举的字符串表示
        "LISTING_WITH_KEY"
        ```
    *   **失败响应 (404 Not Found):** 如果提供商不存在。
    *   **实现:** 调用 `AIService.getProvider(provider).map(AIModelProvider::getModelListingCapability)`。

2.  **现有 Endpoint - 行为明确:**
    *   `GET /api/models/providers/{provider}/info`: 用于获取**不需要** API Key 的模型列表（对应 `LISTING_WITHOUT_KEY` 或 `LISTING_WITH_OR_WITHOUT_KEY` 的无 Key 场景）。
    *   `GET /api/models/providers/{provider}/info/auth`: 用于获取**需要** API Key 的模型列表（对应 `LISTING_WITH_KEY` 或 `LISTING_WITH_OR_WITHOUT_KEY` 的有 Key 场景）。

### 3.4. 控制器 (`UserAIModelConfigController.java`)

1.  **`POST /api/v1/user-ai-configs/users/{userId}/create`:**
    *   **行为明确:** 保存配置时，`isValidated` 字段初始应为 `false`。后台应**异步触发**一次验证过程（调用 `UserAIModelConfigService.validateConfiguration`）。**此接口应立即返回创建的配置对象，不等待验证结果。**
    *   **响应:** 返回创建的 `UserAIModelConfigResponse`，包含初始状态 (`isValidated: false`)。

2.  **`POST /api/v1/user-ai-configs/users/{userId}/validate/{configId}`:**
    *   **行为明确:** 此接口用于**手动触发**对**已保存**配置的验证。
    *   **响应:** 验证成功或失败后，都应返回**更新后**的 `UserAIModelConfigResponse`，包含最新的 `isValidated` 状态。

3.  **`POST /api/v1/user-ai-configs/users/{userId}/list` and `/list-with-api-keys`:**
    *   确保响应中的 `UserAIModelConfigResponse` 包含 `isValidated` 字段，反映数据库中的最新状态。

## 4. 前端需求 (Flutter Dart)

### 4.1. 状态管理 (建议使用 dedicated `ModelConfigBloc`)

1.  **State:**
    *   `selectedProvider`: `String?` - 当前选择的提供商名称。
    *   `providerCapability`: `ModelListingCapability?` - 当前提供商的模型列表能力。
    *   `availableModels`: `List<ModelInfo>` - 当前提供商可用的模型列表（根据是否测试了 Key 动态更新）。
    *   `isLoadingCapability`: `bool` - 是否正在加载提供商能力。
    *   `isLoadingModels`: `bool` - 是否正在加载模型列表。
    *   `isTestingApiKey`: `bool` - 是否正在测试 API Key。
    *   `successfullyTestedKeys`: `Map<String, String>` - 存储本会话中测试成功的 `providerName -> apiKey` 映射。
    *   `userConfigs`: `List<UserAIModelConfigResponse>` - 用户已保存的配置列表 (包含 `isValidated` 状态)。
    *   `validationStates`: `Map<String, bool>` - (可选，用于UI即时反馈) 存储配置 ID 到其验证状态的映射。
    *   `error`: `String?` - 错误信息。

2.  **Events:**
    *   `ProviderSelected(String providerName)`: 用户选择了一个提供商。
    *   `CapabilityLoaded(ModelListingCapability capability)`: (内部事件) 提供商能力加载完成。
    *   `ModelsLoadRequested({String? apiKey, String? apiEndpoint})`: 请求加载模型列表（可带 Key）。
    *   `ModelsLoaded(List<ModelInfo> models)`: (内部事件) 模型列表加载完成。
    *   `ApiKeyTestRequested(String apiKey, String? apiEndpoint)`: 用户点击“测试连接”。
    *   `ApiKeyTestSucceeded(String apiKey, List<ModelInfo> models)`: (内部事件) API Key 测试成功。
    *   `ApiKeyTestFailed(String error)`: (内部事件) API Key 测试失败。
    *   `UserConfigsLoadRequested()`: 请求加载用户配置。
    *   `UserConfigsLoaded(List<UserAIModelConfigResponse> configs)`: (内部事件) 用户配置加载完成。
    *   `SaveConfigRequested(CreateUserAIModelConfigRequest request)`: 用户点击“添加/保存”。
    *   `ConfigSaved(UserAIModelConfigResponse newConfig)`: (内部事件) 配置保存成功。
    *   `ManualValidateRequested(String configId)`: 用户点击手动验证。
    *   `ConfigValidationUpdated(UserAIModelConfigResponse updatedConfig)`: (内部事件) 配置验证状态更新。

3.  **Bloc Logic:**
    *   **`ProviderSelected`:**
        *   更新 `selectedProvider`。
        *   设置 `isLoadingCapability = true`。
        *   调用 API `getProviderCapability(providerName)`。
        *   触发 `CapabilityLoaded`。
    *   **`CapabilityLoaded`:**
        *   更新 `providerCapability`。
        *   设置 `isLoadingCapability = false`。
        *   根据 `capability` 决定下一步：
            *   `LISTING_WITHOUT_KEY`: 触发 `ModelsLoadRequested()`。
            *   `LISTING_WITH_KEY`, `NO_LISTING`, `LISTING_WITH_OR_WITHOUT_KEY`: 可能先加载默认模型 `ModelsLoadRequested()`, 或等待用户输入 Key。
    *   **`ApiKeyTestRequested`:**
        *   检查 `selectedProvider` 是否存在。
        *   设置 `isTestingApiKey = true`。
        *   调用 API `fetchModelsWithAuth(selectedProvider, apiKey, apiEndpoint)`。
        *   成功则触发 `ApiKeyTestSucceeded`。
        *   失败则触发 `ApiKeyTestFailed`。
    *   **`ApiKeyTestSucceeded`:**
        *   更新 `successfullyTestedKeys[selectedProvider] = apiKey`。
        *   更新 `availableModels = models`。
        *   设置 `isTestingApiKey = false`。
    *   **`ApiKeyTestFailed`:**
        *   设置 `isTestingApiKey = false`。
        *   设置 `error`。
    *   **`ModelsLoadRequested`:**
        *   检查 `selectedProvider`。
        *   设置 `isLoadingModels = true`。
        *   判断是否使用 API Key（基于 `apiKey` 参数 或 `successfullyTestedKeys`）。
        *   调用 API `fetchModels` 或 `fetchModelsWithAuth`。
        *   触发 `ModelsLoaded`。
    *   **`ModelsLoaded`:**
        *   更新 `availableModels`。
        *   设置 `isLoadingModels = false`。
    *   **`UserConfigsLoadRequested`:**
        *   调用 API 获取用户配置列表。
        *   触发 `UserConfigsLoaded`。
    *   **`UserConfigsLoaded`:**
        *   更新 `userConfigs`。
        *   更新 `validationStates` (可选)。
    *   **`SaveConfigRequested`:**
        *   调用 API 保存配置。
        *   触发 `ConfigSaved`。
        *   (无需等待后台验证)
    *   **`ConfigSaved`:**
        *   将 `newConfig` 添加/更新到 `userConfigs` 列表。
    *   **`ManualValidateRequested`:**
        *   调用 API `/validate/{configId}`。
        *   触发 `ConfigValidationUpdated`。
    *   **`ConfigValidationUpdated`:**
        *   更新 `userConfigs` 中对应配置的状态。
        *   更新 `validationStates` (可选)。

### 4.2. UI 组件

1.  **Provider 列表 (`ProviderList.dart`):**
    *   `onProviderSelected`: 触发 `ProviderSelected` 事件。

2.  **模型配置主界面 (StatefulWidget):**
    *   **监听 Bloc State:** 根据 `isLoadingCapability`, `isLoadingModels`, `isTestingApiKey` 显示加载指示器。根据 `error` 显示错误提示 (e.g., SnackBar)。
    *   **API Key 输入框 & 测试按钮:**
        *   根据 `providerCapability` (为 `LISTING_WITH_KEY` 或 `LISTING_WITH_OR_WITHOUT_KEY`) 条件渲染。
        *   测试按钮 (`TextButton` 或 `IconButton`):
            *   点击时触发 `ApiKeyTestRequested`。
            *   按钮旁显示加载指示器 (当 `isTestingApiKey` 为 true)。
            *   如果 `successfullyTestedKeys` 包含当前 provider 的 key，显示绿色对勾图标 (`Icons.check_circle`)。
    *   **API Endpoint 输入框:** (保持现有逻辑)
    *   **模型选择 Dropdown/List:**
        *   数据源为 Bloc state 的 `availableModels`。
        *   当 `availableModels` 更新时，自动刷新列表内容。
    *   **别名输入框:** (保持现有逻辑)
    *   **添加/保存按钮 (`ElevatedButton`):**
        *   **启用/禁用逻辑:**
            *   检查 `selectedProvider` 和 `selectedModelName` 是否为空。
            *   检查 `providerCapability` 是否为 `LISTING_WITH_KEY` 且对应的 `apiKey` 未在 `successfullyTestedKeys` 中（或 API Key 字段为空）。
            *   **检查重复:** 遍历 `userConfigs`，查找是否存在 `config.provider == selectedProvider && config.modelName == selectedModelName && config.isValidated == true` 的配置。如果存在，禁用按钮。
        *   **点击:** 触发 `SaveConfigRequested`。
    *   **用户配置列表显示:**
        *   遍历 `userConfigs`。
        *   在每个配置项旁边：
            *   如果 `config.isValidated == true`，显示绿色对勾图标 (`Icons.check_circle, color: Colors.green`)。
            *   (可选) 如果 `config.isValidated == false` 且最近一次验证失败，显示红色错误图标。
            *   提供“重新验证”按钮，点击触发 `ManualValidateRequested(config.id)`。

### 4.3. API 服务 (Dart - `ApiClient` 或 `ModelConfigRepository`)

1.  **添加新方法:**
    *   `Future<ModelListingCapability> getProviderCapability(String providerName)` -> 调用 `GET /api/models/providers/{provider}/capability`
    *   `Future<List<ModelInfo>> fetchModels(String providerName)` -> 调用 `GET /api/models/providers/{provider}/info`
    *   `Future<List<ModelInfo>> fetchModelsWithAuth(String providerName, String apiKey, String? apiEndpoint)` -> 调用 `GET /api/models/providers/{provider}/info/auth`
2.  **确保现有方法:**
    *   `Future<UserAIModelConfigResponse> createConfiguration(...)` -> 调用 `POST /users/{userId}/create`
    *   `Future<List<UserAIModelConfigResponse>> listConfigurations(...)` -> 调用 `POST /users/{userId}/list` 或 `/list-with-api-keys`
    *   `Future<UserAIModelConfigResponse> validateConfiguration(String userId, String configId)` -> 调用 `POST /users/{userId}/validate/{configId}`
    *   (其他更新、删除方法)

## 5. 工作流程示例 (用户添加 OpenAI 配置)

1.  **选择提供商:** 用户在 `ProviderList` 中选择 "OpenAI"。
2.  **加载能力:** 前端触发 `ProviderSelected("openai")`。Bloc 调用 `getProviderCapability("openai")`，收到 `LISTING_WITH_KEY`。State 更新 `providerCapability`。
3.  **UI 更新:** 前端根据 `LISTING_WITH_KEY` 显示 API Key 输入框和“测试连接”按钮。可能先调用 `fetchModels("openai")` 加载默认模型并显示在下拉框中。
4.  **输入 Key 并测试:** 用户输入 OpenAI Key，点击“测试连接”。
5.  **API 测试:** 前端触发 `ApiKeyTestRequested`。Bloc 设置 `isTestingApiKey = true`，调用 `fetchModelsWithAuth("openai", apiKey, endpoint)`。
6.  **获取模型:** 后端 `OpenAILangChain4jModelProvider` 调用 OpenAI API `/models`。成功返回模型列表。
7.  **测试成功:** Bloc 触发 `ApiKeyTestSucceeded`，更新 `successfullyTestedKeys`，更新 `availableModels` 为从 API 获取的列表，设置 `isTestingApiKey = false`。
8.  **UI 更新:** 前端显示绿色对勾，模型下拉框刷新为 GPT-3.5, GPT-4, GPT-4o 等。
9.  **选择模型和别名:** 用户选择 "gpt-4o"，输入别名 "My GPT-4o"。
10. **检查重复:** 前端检查 `userConfigs` 中是否存在已验证的 OpenAI + gpt-4o 配置。假设不存在。
11. **启用按钮:** “添加”按钮变为可用状态。
12. **点击添加:** 用户点击“添加”。前端触发 `SaveConfigRequested`。
13. **保存配置:** Bloc 调用 API `createConfiguration(...)`。
14. **后端处理:** 后端保存配置 (`isValidated = false`)，**异步**开始验证。立即返回新创建的配置。
15. **前端更新:** Bloc 触发 `ConfigSaved`，将新配置（`isValidated = false`）添加到 `userConfigs` 列表。UI 刷新，显示新添加的配置项（无对勾）。
16. **后台验证完成:** (稍后) 后台验证成功，更新数据库 `isValidated = true`。
17. **状态更新 (可选):** 如果使用 SSE 或定时轮询，前端会收到更新，触发 `ConfigValidationUpdated`，更新对应配置的状态。
18. **UI 更新 (最终):** 用户列表中的 "My GPT-4o" 配置项旁显示绿色对勾。如果用户再次尝试添加 OpenAI + gpt-4o，“添加”按钮会因检测到已验证重复项而被禁用。

## 6. 验收标准

*   不同类型的提供商（无 Key、需 Key）能正确显示对应的 UI（API Key 输入框）。
*   为需要 Key 的提供商输入有效 Key 并点击测试后，模型列表能正确刷新为该 Key 可用的模型。
*   API Key 测试按钮能正确显示加载状态和成功状态（对勾）。
*   用户配置列表中，通过后台验证的配置项旁边显示绿色对勾。
*   如果尝试添加与已验证配置具有相同提供商和模型名称的配置，"添加"按钮应被禁用。
*   所有加载过程（能力、模型、测试）应有明确的 UI 反馈（加载指示器）。
*   API 调用失败时应有用户友好的错误提示。
