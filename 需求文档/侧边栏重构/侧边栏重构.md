# 侧边栏目录数据加载优化方案：引入 SidebarBloc

## 1. 问题背景

当前编辑器 (`EditorLayout.dart`) 的核心数据由 `EditorBloc` 管理，并通过调用 `getNovelWithPaginatedScenes` API 进行分页加载，以优化主编辑区的性能。然而，左侧的侧边栏 (`EditorSidebar.dart`) 中的章节目录 (`ChapterDirectoryTab`) 需要展示**完整**的小说结构（所有卷、章节）以及每个场景的**摘要**信息，以便用户快速导航。

直接使用 `EditorBloc` 中分页加载、且包含完整场景内容的数据来渲染侧边栏目录存在以下问题：

*   **数据不完整:** 无法显示未被分页加载的章节。
*   **数据冗余/性能问题:** 侧边栏只需要场景摘要，但加载了完整的场景内容，造成不必要的网络和内存开销。

## 2. 解决方案：引入 SidebarBloc

为了解决上述问题，我们引入一个新的 Bloc：`SidebarBloc`，专门负责加载和管理侧边栏目录所需的**完整小说结构和场景摘要数据**。这使得侧边栏的数据流与编辑器主体的数据流解耦。

我们利用现有的后端 API `/novels/get-with-scene-summaries` 和前端 Repository 方法 `getNovelWithSceneSummaries`，该方法能够获取包含完整结构和场景摘要的小说数据。

## 3. 实现步骤

### 3.1 创建 SidebarBloc

创建新的 Bloc 文件 `lib/blocs/sidebar/sidebar_bloc.dart` (以及对应的 `sidebar_event.dart`, `sidebar_state.dart`)。

**a) SidebarEvent (`sidebar_event.dart`):**

```dart
part of 'sidebar_bloc.dart';

abstract class SidebarEvent extends Equatable {
  const SidebarEvent();

  @override
  List<Object> get props => [];
}

// 加载小说结构和摘要事件
class LoadNovelStructure extends SidebarEvent {
  final String novelId;

  const LoadNovelStructure(this.novelId);

  @override
  List<Object> get props => [novelId];
}
```

**b) SidebarState (`sidebar_state.dart`):**

```dart
part of 'sidebar_bloc.dart';

// 注意：这里的 Novel 模型应该是包含了完整结构和场景摘要信息的版本。
// 如果现有 Novel 模型不包含摘要，可能需要创建一个新的模型如 NovelWithSummaries。
// 此处假设 getNovelWithSceneSummaries 返回的 Novel 对象已包含所需信息。
abstract class SidebarState extends Equatable {
  const SidebarState();

  @override
  List<Object?> get props => [];
}

class SidebarInitial extends SidebarState {}

class SidebarLoading extends SidebarState {}

class SidebarLoaded extends SidebarState {
  final Novel novelStructure; // 包含完整结构和场景摘要的小说对象

  const SidebarLoaded(this.novelStructure);

  @override
  List<Object?> get props => [novelStructure];
}

class SidebarError extends SidebarState {
  final String message;

  const SidebarError(this.message);

  @override
  List<Object?> get props => [message];
}

```

**c) SidebarBloc (`sidebar_bloc.dart`):**

```dart
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:ainoval/models/novel_structure.dart'; // 假设 Novel 在这里
import 'package:ainoval/services/api_service/repositories/editor_repository.dart'; // 引入 Repository
import 'package:ainoval/utils/logger.dart';

part 'sidebar_event.dart';
part 'sidebar_state.dart';

class SidebarBloc extends Bloc<SidebarEvent, SidebarState> {
  final EditorRepository _editorRepository; // 依赖注入 EditorRepository

  SidebarBloc({required EditorRepository editorRepository})
      : _editorRepository = editorRepository,
        super(SidebarInitial()) {
    on<LoadNovelStructure>(_onLoadNovelStructure);
  }

  Future<void> _onLoadNovelStructure(
      LoadNovelStructure event, Emitter<SidebarState> emit) async {
    emit(SidebarLoading());
    try {
      final novelStructure = await _editorRepository.getNovelWithSceneSummaries(event.novelId);
      if (novelStructure != null) {
        emit(SidebarLoaded(novelStructure));
        AppLogger.i('SidebarBloc', '成功加载小说结构与摘要: ${event.novelId}');
      } else {
        emit(const SidebarError('未能加载小说结构'));
        AppLogger.w('SidebarBloc', '加载小说结构与摘要失败，返回 null: ${event.novelId}');
      }
    } catch (e) {
      emit(SidebarError('加载小说结构时出错: ${e.toString()}'));
      AppLogger.e('SidebarBloc', '加载小说结构与摘要时捕获异常', e);
    }
  }
}
```

### 3.2 在 EditorScreen 或上层提供 SidebarBloc

在 `EditorScreen` (或其父级 Widget，例如创建 `EditorScreen` 的地方) 使用 `BlocProvider` 来创建和提供 `SidebarBloc` 实例。确保它能被 `EditorSidebar` 访问到。

```dart
// 在 EditorScreen 或其创建处
BlocProvider<SidebarBloc>(
  create: (context) => SidebarBloc(
    editorRepository: RepositoryProvider.of<EditorRepository>(context), // 获取 EditorRepository 实例
  )..add(LoadNovelStructure(novelId)), // 创建时即触发加载事件
  child: EditorLayout(
    // ... 其他参数 ...
  ),
)
```

*   **注意:** 需要确保 `EditorRepository` 实例在此处可用。如果它是在 `EditorScreen` 内部创建的，需要调整提供的位置或方式。

### 3.3 修改 ChapterDirectoryTab 使用 SidebarBloc

修改 `lib/screens/editor/components/editor_sidebar.dart` 中的 `ChapterDirectoryTab` Widget。

*   移除或修改 `initState` 中依赖 `EditorBloc` 来初始化展开状态的部分，可以改为依赖 `SidebarBloc` 的 `SidebarLoaded` 状态。
*   将 `build` 方法包裹在 `BlocBuilder<SidebarBloc, SidebarState>` 中。
*   在 `BlocBuilder` 的 `builder` 回调中，根据 `SidebarState` 的不同状态显示 UI (Loading, Error, Loaded)。
*   当状态是 `SidebarLoaded` 时，使用 `state.novelStructure` 来渲染章节和场景列表 (`_buildChapterList`, `_buildScenesList`)，而不是原来依赖 `EditorBloc` 状态中的 `novel`。

```dart
// ChapterDirectoryTab build 方法示例
@override
Widget build(BuildContext context) {
  final theme = Theme.of(context);

  // 使用 BlocBuilder 监听 SidebarBloc
  return BlocBuilder<SidebarBloc, SidebarState>(
    builder: (context, sidebarState) {
      if (sidebarState is SidebarLoading) {
        return const Center(child: CircularProgressIndicator());
      } else if (sidebarState is SidebarLoaded) {
        // 使用加载到的完整结构 novelStructure 来构建 UI
        final novelStructure = sidebarState.novelStructure;
        return Container(
          color: Colors.grey.shade50,
          child: Column(
            children: [
              _buildSearchAndJumpSection(theme),
              Expanded(
                child: novelStructure.acts.isEmpty
                    ? _buildEmptyState(theme)
                    // 传递加载到的完整结构数据
                    : _buildChapterList(novelStructure, theme),
              ),
            ],
          ),
        );
      } else if (sidebarState is SidebarError) {
        return Center(
          child: Text('加载目录失败: ${sidebarState.message}', style: TextStyle(color: Colors.red.shade700)),
        );
      } else {
        // SidebarInitial 状态
        return const Center(child: Text('正在初始化目录...'));
      }
    },
  );
}

// _buildChapterList 方法签名修改示例
Widget _buildChapterList(novel_models.Novel novelStructure, ThemeData theme) {
  // ... 方法内部逻辑使用 novelStructure ...
}

// _buildScenesList 方法逻辑调整
// 确认 novelStructure.acts[x].chapters[y].scenes 包含的是带摘要的 Scene 对象或 SceneSummaryDto 对象
Widget _buildScenesList(
  String actId,
  novel_models.Chapter chapter, // chapter 来自 novelStructure
  String searchText,
  ThemeData theme
) {
  // ... 确保 chapter.scenes 包含的是摘要信息 ...
  // ... 访问 scene.summary 来显示摘要 ...
}
```

### 3.4 调整场景跳转逻辑 (如果需要)

`ChapterDirectoryTab` 中的 `_navigateToScene` 方法用于在用户点击场景时，通知 `EditorBloc` 加载该场景的**完整内容**并滚动到视图中。**这个逻辑通常不需要改变**，因为它仍然需要触发主编辑区的数据加载和状态更新。

## 4. 优势总结

*   **数据解耦:** 侧边栏目录的展示数据与主编辑器的分页编辑数据分离。
*   **性能提升:** 侧边栏仅加载必要的结构和摘要信息，显著减少了初次加载和渲染侧边栏的网络请求数据量和内存占用。
*   **用户体验改善:** 用户可以快速看到完整的小说目录结构，导航更流畅。
*   **代码结构清晰:** `SidebarBloc` 专门处理侧边栏数据，`EditorBloc` 职责更单一，代码更易于维护。

通过实施此方案，可以有效地解决侧边栏目录的数据加载问题，并提升应用的整体性能和用户体验。

根据以上需求和文档，帮我修改代码，重构左侧边栏@editor_main_area.dart @editor_layout.dart @editor_sidebar.dart @editor_screen_controller.dart @editor_screen.dart 