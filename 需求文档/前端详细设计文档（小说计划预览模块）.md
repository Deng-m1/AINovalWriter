

## 小说计划预览模块详细设计

### 1. 模块概述

小说计划预览模块提供了小说结构的可视化和管理功能，允许作者查看和组织小说的章节、场景，并提供整体规划和进度跟踪。该模块支持拖拽重排序、章节扩展和场景管理，并与AI集成以获取创作建议。

### 2. 数据模型

```dart
// 小说结构模型
class NovelStructure {
  final String novelId;
  final String title;
  final List<ChapterOutline> chapters;
  final int totalWordCount;
  final int targetWordCount;
  final double completionPercentage;
  
  NovelStructure({
    required this.novelId,
    required this.title,
    required this.chapters,
    this.totalWordCount = 0,
    this.targetWordCount = 0,
    this.completionPercentage = 0.0,
  });
}

// 章节大纲模型
class ChapterOutline {
  final String id;
  final String title;
  final int order;
  final String? summary;
  final List<SceneOutline> scenes;
  final int wordCount;
  final ChapterStatus status;
  
  ChapterOutline({
    required this.id,
    required this.title,
    required this.order,
    this.summary,
    required this.scenes,
    this.wordCount = 0,
    this.status = ChapterStatus.planned,
  });
  
  // 计算完成状态
  ChapterStatus calculateStatus() {
    if (scenes.isEmpty) {
      return ChapterStatus.planned;
    }
    
    final completedScenes = scenes.where((s) => 
        s.status == SceneStatus.completed).length;
    
    if (completedScenes == 0) {
      return ChapterStatus.planned;
    } else if (completedScenes == scenes.length) {
      return ChapterStatus.completed;
    } else {
      return ChapterStatus.inProgress;
    }
  }
  
  // 创建副本
  ChapterOutline copyWith({
    String? id,
    String? title,
    int? order,
    String? summary,
    List<SceneOutline>? scenes,
    int? wordCount,
    ChapterStatus? status,
  }) {
    return ChapterOutline(
      id: id ?? this.id,
      title: title ?? this.title,
      order: order ?? this.order,
      summary: summary ?? this.summary,
      scenes: scenes ?? this.scenes,
      wordCount: wordCount ?? this.wordCount,
      status: status ?? this.status,
    );
  }
}

// 场景大纲模型
class SceneOutline {
  final String id;
  final String title;
  final int order;
  final String? summary;
  final int wordCount;
  final SceneStatus status;
  final List<String>? characterIds;
  final String? locationId;
  final String? pov;
  
  SceneOutline({
    required this.id,
    required this.title,
    required this.order,
    this.summary,
    this.wordCount = 0,
    this.status = SceneStatus.planned,
    this.characterIds,
    this.locationId,
    this.pov,
  });
  
  // 创建副本
  SceneOutline copyWith({
    String? id,
    String? title,
    int? order,
    String? summary,
    int? wordCount,
    SceneStatus? status,
    List<String>? characterIds,
    String? locationId,
    String? pov,
  }) {
    return SceneOutline(
      id: id ?? this.id,
      title: title ?? this.title,
      order: order ?? this.order,
      summary: summary ?? this.summary,
      wordCount: wordCount ?? this.wordCount,
      status: status ?? this.status,
      characterIds: characterIds ?? this.characterIds,
      locationId: locationId ?? this.locationId,
      pov: pov ?? this.pov,
    );
  }
}

// 章节状态
enum ChapterStatus {
  planned,      // 计划中
  inProgress,   // 进行中
  completed,    // 已完成
  revision,     // 修订中
}

// 场景状态
enum SceneStatus {
  planned,      // 计划中
  drafted,      // 已起草
  completed,    // 已完成
  revision,     // 修订中
}
```

### 3. 状态管理

```dart
// 小说计划状态管理
class NovelPlanBloc extends Bloc<NovelPlanEvent, NovelPlanState> {
  final NovelPlanRepository repository;
  
  NovelPlanBloc({required this.repository}) : super(NovelPlanInitial()) {
    on<LoadNovelStructure>(_onLoadStructure);
    on<AddChapter>(_onAddChapter);
    on<UpdateChapter>(_onUpdateChapter);
    on<DeleteChapter>(_onDeleteChapter);
    on<ReorderChapters>(_onReorderChapters);
    on<AddScene>(_onAddScene);
    on<UpdateScene>(_onUpdateScene);
    on<DeleteScene>(_onDeleteScene);
    on<ReorderScenes>(_onReorderScenes);
    on<GenerateChapterWithAI>(_onGenerateChapterWithAI);
    on<GenerateSceneWithAI>(_onGenerateSceneWithAI);
  }
  
  Future<void> _onLoadStructure(LoadNovelStructure event, Emitter<NovelPlanState> emit) async {
    emit(NovelPlanLoading());
    
    try {
      final structure = await repository.getNovelStructure(event.novelId);
      emit(NovelPlanLoaded(structure: structure));
    } catch (e) {
      emit(NovelPlanError(message: '加载小说结构失败: ${e.toString()}'));
    }
  }
  
  Future<void> _onAddChapter(AddChapter event, Emitter<NovelPlanState> emit) async {
    if (state is NovelPlanLoaded) {
      final currentState = state as NovelPlanLoaded;
      final structure = currentState.structure;
      
      try {
        // 计算新章节的顺序
        final nextOrder = structure.chapters.isEmpty 
            ? 1 
            : structure.chapters.map((c) => c.order).reduce(max) + 1;
        
        // 创建新章节
        final newChapter = ChapterOutline(
          id: UUID.v4(),
          title: event.title.isEmpty ? '第$nextOrder章' : event.title,
          order: nextOrder,
          scenes: [],
        );
        
        // 更新结构
        final updatedChapters = [...structure.chapters, newChapter];
        final updatedStructure = NovelStructure(
          novelId: structure.novelId,
          title: structure.title,
          chapters: updatedChapters,
          totalWordCount: structure.totalWordCount,
          targetWordCount: structure.targetWordCount,
          completionPercentage: structure.completionPercentage,
        );
        
        // 保存到仓库
        await repository.saveNovelStructure(updatedStructure);
        
        // 更新状态
        emit(NovelPlanLoaded(structure: updatedStructure));
      } catch (e) {
        emit(NovelPlanError(message: '添加章节失败: ${e.toString()}'));
      }
    }
  }

  Future<void> _onReorderChapters(ReorderChapters event, Emitter<NovelPlanState> emit) async {
    if (state is NovelPlanLoaded) {
      final currentState = state as NovelPlanLoaded;
      final structure = currentState.structure;
      
      try {
        // 克隆章节列表
        final chapters = List<ChapterOutline>.from(structure.chapters);
        
        // 移动项目
        final movedItem = chapters.removeAt(event.oldIndex);
        chapters.insert(event.newIndex, movedItem);
        
        // 更新顺序
        for (int i = 0; i < chapters.length; i++) {
          chapters[i] = chapters[i].copyWith(order: i + 1);
        }
        
        // 更新结构
        final updatedStructure = NovelStructure(
          novelId: structure.novelId,
          title: structure.title,
          chapters: chapters,
          totalWordCount: structure.totalWordCount,
          targetWordCount: structure.targetWordCount,
          completionPercentage: structure.completionPercentage,
        );
        
        // 保存到仓库
        await repository.saveNovelStructure(updatedStructure);
        
        // 更新状态
        emit(NovelPlanLoaded(structure: updatedStructure));
      } catch (e) {
        emit(NovelPlanError(message: '重排章节失败: ${e.toString()}'));
      }
    }
  }
  
  Future<void> _onAddScene(AddScene event, Emitter<NovelPlanState> emit) async {
    if (state is NovelPlanLoaded) {
      final currentState = state as NovelPlanLoaded;
      final structure = currentState.structure;
      
      try {
        // 查找章节
        final chapterIndex = structure.chapters.indexWhere((c) => c.id == event.chapterId);
        if (chapterIndex == -1) {
          throw Exception('未找到章节');
        }
        
        final chapter = structure.chapters[chapterIndex];
        
        // 计算新场景的顺序
        final nextOrder = chapter.scenes.isEmpty 
            ? 1 
            : chapter.scenes.map((s) => s.order).reduce(max) + 1;
        
        // 创建新场景
        final newScene = SceneOutline(
          id: UUID.v4(),
          title: event.title.isEmpty ? '场景 $nextOrder' : event.title,
          order: nextOrder,
        );
        
        // 更新章节
        final updatedScenes = [...chapter.scenes, newScene];
        final updatedChapter = chapter.copyWith(scenes: updatedScenes);
        
        // 更新章节列表
        final updatedChapters = List<ChapterOutline>.from(structure.chapters);
        updatedChapters[chapterIndex] = updatedChapter;
        
        // 更新结构
        final updatedStructure = NovelStructure(
          novelId: structure.novelId,
          title: structure.title,
          chapters: updatedChapters,
          totalWordCount: structure.totalWordCount,
          targetWordCount: structure.targetWordCount,
          completionPercentage: structure.completionPercentage,
        );
        
        // 保存到仓库
        await repository.saveNovelStructure(updatedStructure);
        
        // 更新状态
        emit(NovelPlanLoaded(structure: updatedStructure));
      } catch (e) {
        emit(NovelPlanError(message: '添加场景失败: ${e.toString()}'));
      }
    }
  }
  
  Future<void> _onGenerateChapterWithAI(GenerateChapterWithAI event, Emitter<NovelPlanState> emit) async {
    if (state is NovelPlanLoaded) {
      emit(NovelPlanGenerating());
      
      try {
        final currentState = state as NovelPlanLoaded;
        final structure = currentState.structure;
        
        // 使用AI生成章节大纲
        final generatedChapter = await repository.generateChapterWithAI(
          novelId: structure.novelId,
          chapterPrompt: event.prompt,
          previousChapters: structure.chapters,
        );
        
        // 计算新章节的顺序
        final nextOrder = structure.chapters.isEmpty 
            ? 1 
            : structure.chapters.map((c) => c.order).reduce(max) + 1;
        
        // 更新顺序
        final newChapter = generatedChapter.copyWith(order: nextOrder);
        
        // 更新结构
        final updatedChapters = [...structure.chapters, newChapter];
        final updatedStructure = NovelStructure(
          novelId: structure.novelId,
          title: structure.title,
          chapters: updatedChapters,
          totalWordCount: structure.totalWordCount,
          targetWordCount: structure.targetWordCount,
          completionPercentage: structure.completionPercentage,
        );
        
        // 保存到仓库
        await repository.saveNovelStructure(updatedStructure);
        
        // 更新状态
        emit(NovelPlanLoaded(structure: updatedStructure));
      } catch (e) {
        emit(NovelPlanError(message: 'AI生成章节失败: ${e.toString()}'));
      }
    }
  }
  
  // 其他事件处理方法...
}

// 事件定义
abstract class NovelPlanEvent {}

class LoadNovelStructure extends NovelPlanEvent {
  final String novelId;
  
  LoadNovelStructure({required this.novelId});
}

class AddChapter extends NovelPlanEvent {
  final String title;
  
  AddChapter({this.title = ''});
}

class UpdateChapter extends NovelPlanEvent {
  final String chapterId;
  final String? title;
  final String? summary;
  
  UpdateChapter({
    required this.chapterId,
    this.title,
    this.summary,
  });
}

class DeleteChapter extends NovelPlanEvent {
  final String chapterId;
  
  DeleteChapter({required this.chapterId});
}

class ReorderChapters extends NovelPlanEvent {
  final int oldIndex;
  final int newIndex;
  
  ReorderChapters({
    required this.oldIndex,
    required this.newIndex,
  });
}

class AddScene extends NovelPlanEvent {
  final String chapterId;
  final String title;
  
  AddScene({
    required this.chapterId,
    this.title = '',
  });
}

// 其他事件类...

// 状态定义
abstract class NovelPlanState {}

class NovelPlanInitial extends NovelPlanState {}
class NovelPlanLoading extends NovelPlanState {}
class NovelPlanGenerating extends NovelPlanState {}
class NovelPlanLoaded extends NovelPlanState {
  final NovelStructure structure;
  
  NovelPlanLoaded({required this.structure});
}
class NovelPlanError extends NovelPlanState {
  final String message;
  
  NovelPlanError({required this.message});
}
```

### 4. UI组件结构

```
NovelPlanScreen
├── AppBar
│   ├── BackButton
│   ├── TitleText
│   ├── ViewToggleButtons (Grid/List)
│   └── SettingsButton
├── StructureSummaryCard
│   ├── NovelTitleText
│   ├── StatsSection
│   │   ├── ChapterCountInfo
│   │   ├── WordCountInfo
│   │   └── CompletionProgressBar
│   └── TargetSettingsButton
├── GridView/ListView
│   ├── ChapterRows
│   │   ├── ChapterHeader
│   │   │   ├── ChapterOrderBadge
│   │   │   ├── ChapterTitleText
│   │   │   ├── WordCountLabel
│   │   │   ├── StatusIndicator
│   │   │   └── ChapterActionButtons
│   │   │       ├── EditButton
│   │   │       ├── AddSceneButton
│   │   │       └── DeleteButton
│   │   └── ScenesContainer
│   │       ├── SceneCards
│   │       │   ├── SceneTitleText
│   │       │   ├── StatusIndicator
│   │       │   ├── SummaryText (truncated)
│   │       │   └── SceneActionButtons
│   │       │       ├── EditButton
│   │       │       ├── OpenInEditorButton
│   │       │       └── DeleteButton
│   │       └── AddSceneButton
│   └── ChapterDividers
├── FABs
│   ├── AddChapterFAB
│   └── AIGenerateFAB
└── ChapterSortableArea (for drag and drop)
```

### 5. 核心功能实现

#### 5.1 章节卡片组件

```dart
class ChapterCard extends StatelessWidget {
  final ChapterOutline chapter;
  final Function(ChapterOutline) onEdit;
  final Function(String) onDelete;
  final Function(String) onAddScene;
  final Function(SceneOutline) onEditScene;
  final Function(String) onDeleteScene;
  final Function(String) onOpenSceneInEditor;
  
  const ChapterCard({
    Key? key,
    required this.chapter,
    required this.onEdit,
    required this.onDelete,
    required this.onAddScene,
    required this.onEditScene,
    required this.onDeleteScene,
    required this.onOpenSceneInEditor,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
      elevation: 2,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 章节标题栏
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surface,
              borderRadius: BorderRadius.vertical(top: Radius.circular(12)),
            ),
            child: Row(
              children: [
                // 章节序号
                Container(
                  width: 32,
                  height: 32,
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primary,
                    shape: BoxShape.circle,
                  ),
                  child: Center(
                    child: Text(
                      chapter.order.toString(),
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onPrimary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
                SizedBox(width: 12),
                
                // 标题和状态
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        chapter.title,
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                      SizedBox(height: 4),
                      Row(
                        children: [
                          _buildStatusIndicator(context),
                          SizedBox(width: 8),
                          Text(
                            '${chapter.wordCount} 字 · ${chapter.scenes.length} 场景',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                
                // 操作按钮
                IconButton(
                  icon: Icon(Icons.edit, size: 20),
                  onPressed: () => onEdit(chapter),
                  tooltip: '编辑章节',
                ),
                IconButton(
                  icon: Icon(Icons.delete, size: 20),
                  onPressed: () => _confirmDelete(context),
                  tooltip: '删除章节',
                ),
              ],
            ),
          ),
          
          // 章节摘要（如果有）
          if (chapter.summary != null && chapter.summary!.isNotEmpty)
            Padding(
              padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Text(
                chapter.summary!,
                style: TextStyle(
                  fontStyle: FontStyle.italic,
                  color: Theme.of(context).colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ),
          
          // 场景列表
          if (chapter.scenes.isNotEmpty)
            ListView.separated(
              shrinkWrap: true,
              physics: NeverScrollableScrollPhysics(),
              itemCount: chapter.scenes.length,
              separatorBuilder: (context, index) => Divider(height: 1),
              itemBuilder: (context, index) {
                final scene = chapter.scenes[index];
                return SceneListItem(
                  scene: scene,
                  onEdit: () => onEditScene(scene),
                  onDelete: () => _confirmDeleteScene(context, scene),
                  onOpenInEditor: () => onOpenSceneInEditor(scene.id),
                );
              },
            ),
          
          // 添加场景按钮
          Padding(
            padding: EdgeInsets.all(16),
            child: Center(
              child: OutlinedButton.icon(
                onPressed: () => onAddScene(chapter.id),
                icon: Icon(Icons.add),
                label: Text('添加场景'),
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  // 构建状态指示器
  Widget _buildStatusIndicator(BuildContext context) {
    Color color;
    String label;
    
    switch (chapter.status) {
      case ChapterStatus.planned:
        color = Colors.grey;
        label = '计划中';
        break;
      case ChapterStatus.inProgress:
        color = Colors.blue;
        label = '进行中';
        break;
      case ChapterStatus.completed:
        color = Colors.green;
        label = '已完成';
        break;
      case ChapterStatus.revision:
        color = Colors.orange;
        label = '修订中';
        break;
    }
    
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: color),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  // 确认删除对话框
  void _confirmDelete(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('确认删除'),
        content: Text('确定要删除章节"${chapter.title}"吗？此操作不可撤销，将删除章节中的所有场景。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('取消'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              onDelete(chapter.id);
            },
            child: Text('删除'),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
          ),
        ],
      ),
    );
  }
  
  // 确认删除场景对话框
  void _confirmDeleteScene(BuildContext context, SceneOutline scene) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('确认删除'),
        content: Text('确定要删除场景"${scene.title}"吗？此操作不可撤销。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('取消'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              onDeleteScene(scene.id);
            },
            child: Text('删除'),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
          ),
        ],
      ),
    );
  }
}
```

#### 5.2 场景列表项组件

```dart
class SceneListItem extends StatelessWidget {
  final SceneOutline scene;
  final VoidCallback onEdit;
  final VoidCallback onDelete;
  final VoidCallback onOpenInEditor;
  
  const SceneListItem({
    Key? key,
    required this.scene,
    required this.onEdit,
    required this.onDelete,
    required this.onOpenInEditor,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: Theme.of(context).colorScheme.surface,
        child: Text(
          scene.order.toString(),
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
      title: Text(scene.title),
      subtitle: scene.summary != null && scene.summary!.isNotEmpty
          ? Text(
              scene.summary!,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            )
          : Text(
              '无场景摘要',
              style: TextStyle(fontStyle: FontStyle.italic),
            ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildStatusChip(),
          IconButton(
            icon: Icon(Icons.edit, size: 18),
            onPressed: onEdit,
            tooltip: '编辑场景',
          ),
          IconButton(
            icon: Icon(Icons.open_in_new, size: 18),
            onPressed: onOpenInEditor,
            tooltip: '在编辑器中打开',
          ),
          IconButton(
            icon: Icon(Icons.delete, size: 18),
            onPressed: onDelete,
            tooltip: '删除场景',
          ),
        ],
      ),
      onTap: onEdit,
    );
  }
  
  // 构建状态指示器
  Widget _buildStatusChip() {
    Color color;
    IconData icon;
    
    switch (scene.status) {
      case SceneStatus.planned:
        color = Colors.grey;
        icon = Icons.schedule;
        break;
      case SceneStatus.drafted:
        color = Colors.blue;
        icon = Icons.edit_note;
        break;
      case SceneStatus.completed:
        color = Colors.green;
        icon = Icons.check_circle;
        break;
      case SceneStatus.revision:
        color = Colors.orange;
        icon = Icons.auto_fix_high;
        break;
    }
    
    return Icon(icon, color: color, size: 16);
  }
}
```

#### 5.3 可排序的章节列表

```dart
class SortableChaptersList extends StatefulWidget {
  final List<ChapterOutline> chapters;
  final Function(int, int) onReorder;
  final Function(ChapterOutline) onEditChapter;
  final Function(String) onDeleteChapter;
  final Function(String) onAddScene;
  final Function(SceneOutline) onEditScene;
  final Function(String) onDeleteScene;
  final Function(String) onOpenSceneInEditor;
  
  const SortableChaptersList({
    Key? key,
    required this.chapters,
    required this.onReorder,
    required this.onEditChapter,
    required this.onDeleteChapter,
    required this.onAddScene,
    required this.onEditScene,
    required this.onDeleteScene,
    required this.onOpenSceneInEditor,
  }) : super(key: key);
  
  @override
  State<SortableChaptersList> createState() => _SortableChaptersListState();
}

class _SortableChaptersListState extends State<SortableChaptersList> {
  @override
  Widget build(BuildContext context) {
    return ReorderableListView.builder(
      itemCount: widget.chapters.length,
      onReorder: widget.onReorder,
      itemBuilder: (context, index) {
        final chapter = widget.chapters[index];
        return KeyedSubtree(
          key: ValueKey(chapter.id),
          child: ChapterCard(
            chapter: chapter,
            onEdit: widget.onEditChapter,
            onDelete: widget.onDeleteChapter,
            onAddScene: widget.onAddScene,
            onEditScene: widget.onEditScene,
            onDeleteScene: widget.onDeleteScene,
            onOpenSceneInEditor: widget.onOpenSceneInEditor,
          ),
        );
      },
    );
  }
}
```

#### 5.4 AI章节生成对话框

```dart
class AIChapterGeneratorDialog extends StatefulWidget {
  final String novelId;
  final List<ChapterOutline> existingChapters;
  final Function(ChapterOutline) onChapterGenerated;
  
  const AIChapterGeneratorDialog({
    Key? key,
    required this.novelId,
    required this.existingChapters,
    required this.onChapterGenerated,
  }) : super(key: key);
  
  @override
  State<AIChapterGeneratorDialog> createState() => _AIChapterGeneratorDialogState();
}

class _AIChapterGeneratorDialogState extends State<AIChapterGeneratorDialog> {
  final TextEditingController _promptController = TextEditingController();
  bool _isGenerating = false;
  String? _error;
  ChapterOutline? _generatedChapter;
  
  @override
  void initState() {
    super.initState();
    
    // 设置默认提示语
    _promptController.text = _generateDefaultPrompt();
  }
  
  String _generateDefaultPrompt() {
    final buffer = StringBuffer();
    
    if (widget.existingChapters.isEmpty) {
      buffer.write('为小说创建第一章。');
    } else {
      final lastChapter = widget.existingChapters.last;
      buffer.write('基于前面的章节，为小说创建新的一章。');
      if (lastChapter.summary != null && lastChapter.summary!.isNotEmpty) {
        buffer.write('前一章的摘要：${lastChapter.summary}');
      }
    }
    
    return buffer.toString();
  }
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('使用AI生成章节'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('提供简短的描述或提示，AI将根据已有内容生成新章节的大纲。'),
            SizedBox(height: 16),
            
            TextField(
              controller: _promptController,
              decoration: InputDecoration(
                labelText: '提示语',
                hintText: '例如：主角遇到一个神秘人物...',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
            
            if (_error != null) ...[
              SizedBox(height: 16),
              Text(
                _error!,
                style: TextStyle(color: Colors.red),
              ),
            ],
            
            if (_generatedChapter != null) ...[
              SizedBox(height: 16),
              Card(
                child: Padding(
                  padding: EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '生成结果',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                      SizedBox(height: 8),
                      Text(
                        _generatedChapter!.title,
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      SizedBox(height: 4),
                      Text(_generatedChapter!.summary ?? '无摘要'),
                      if (_generatedChapter!.scenes.isNotEmpty) ...[
                        SizedBox(height: 8),
                        Text(
                          '场景（${_generatedChapter!.scenes.length}个）：',
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        SizedBox(height: 4),
                        ...(_generatedChapter!.scenes.map((scene) {
                          return Padding(
                            padding: EdgeInsets.only(bottom: 4),
                            child: Text('• ${scene.title}'),
                          );
                        }).toList()),
                      ],
                    ],
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('取消'),
        ),
        if (_generatedChapter != null)
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              widget.onChapterGenerated(_generatedChapter!);
            },
            child: Text('使用此大纲'),
          )
        else
          ElevatedButton(
            onPressed: _isGenerating ? null : _generateChapter,
            child: _isGenerating
                ? SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text('生成'),
          ),
      ],
    );
  }
  
  Future<void> _generateChapter() async {
    if (_promptController.text.trim().isEmpty) {
      setState(() {
        _error = '请输入提示语';
      });
      return;
    }
    
    setState(() {
      _isGenerating = true;
      _error = null;
    });
    
    try {
      final repository = context.read<NovelPlanRepository>();
      
      final chapter = await repository.generateChapterWithAI(
        novelId: widget.novelId,
        chapterPrompt: _promptController.text,
        previousChapters: widget.existingChapters,
      );
      
      setState(() {
        _isGenerating = false;
        _generatedChapter = chapter;
      });
    } catch (e) {
      setState(() {
        _isGenerating = false;
        _error = '生成失败：${e.toString()}';
      });
    }
  }
  
  @override
  void dispose() {
    _promptController.dispose();
    super.dispose();
  }
}
```

### 6. API交互

```dart
class NovelPlanRepository {
  final ApiService apiService;
  final LocalStorageService localStorageService;
  
  NovelPlanRepository({
    required this.apiService,
    required this.localStorageService,
  });
  
  // 获取小说结构
  Future<NovelStructure> getNovelStructure(String novelId) async {
    try {
      // 尝试从服务器获取
      final structure = await apiService.fetchNovelStructure(novelId);
      
      // 保存到本地缓存
      await localStorageService.saveNovelStructure(structure);
      
      return structure;
    } catch (e) {
      // 如果服务器请求失败，尝试从本地获取
      final localStructure = await localStorageService.getNovelStructure(novelId);
      
      if (localStructure != null) {
        return localStructure;
      }
      
      // 如果本地也没有，创建新的空结构
      final novel = await apiService.fetchNovelBasicInfo(novelId);
      
      return NovelStructure(
        novelId: novelId,
        title: novel.title,
        chapters: [],
      );
    }
  }
  
  // 保存小说结构
  Future<void> saveNovelStructure(NovelStructure structure) async {
    try {
      // 保存到服务器
      await apiService.saveNovelStructure(structure);
      
      // 更新本地缓存
      await localStorageService.saveNovelStructure(structure);
    } catch (e) {
      // 如果服务器请求失败，仅保存到本地并标记为需要同步
      await localStorageService.saveNovelStructure(
        structure,
        needsSync: true,
      );
    }
  }
  
  // 添加章节
  Future<ChapterOutline> addChapter(
    String novelId,
    String title,
    String? summary,
  ) async {
    try {
      // 获取当前结构
      final structure = await getNovelStructure(novelId);
      
      // 计算新章节的顺序
      final nextOrder = structure.chapters.isEmpty 
          ? 1 
          : structure.chapters.map((c) => c.order).reduce(max) + 1;
      
      // 创建新章节
      final newChapter = ChapterOutline(
        id: UUID.v4(),
        title: title.isEmpty ? '第$nextOrder章' : title,
        order: nextOrder,
        summary: summary,
        scenes: [],
      );
      
      // 添加到服务器
      await apiService.addChapter(novelId, newChapter);
      
      // 更新本地结构
      final updatedChapters = [...structure.chapters, newChapter];
      final updatedStructure = NovelStructure(
        novelId: structure.novelId,
        title: structure.title,
        chapters: updatedChapters,
        totalWordCount: structure.totalWordCount,
        targetWordCount: structure.targetWordCount,
        completionPercentage: structure.completionPercentage,
      );
      
      await localStorageService.saveNovelStructure(updatedStructure);
      
      return newChapter;
    } catch (e) {
      throw Exception('添加章节失败: $e');
    }
  }
  
  // 使用AI生成章节
  Future<ChapterOutline> generateChapterWithAI({
    required String novelId,
    required String chapterPrompt,
    required List<ChapterOutline> previousChapters,
  }) async {
    return await apiService.generateChapterWithAI(
      novelId: novelId,
      chapterPrompt: chapterPrompt,
      previousChapters: previousChapters,
    );
  }
  
  // 使用AI生成场景
  Future<SceneOutline> generateSceneWithAI({
    required String novelId,
    required String chapterId,
    required String scenePrompt,
    required List<SceneOutline> existingScenes,
  }) async {
    return await apiService.generateSceneWithAI(
      novelId: novelId,
      chapterId: chapterId,
      scenePrompt: scenePrompt,
      existingScenes: existingScenes,
    );
  }
  
  // 其他方法...
}
```

### 7. 主要性能优化

```dart
// 使用Hero动画平滑过渡
class ChapterCardWithHero extends StatelessWidget {
  final ChapterOutline chapter;
  final Function(ChapterOutline) onTap;
  
  const ChapterCardWithHero({
    Key? key,
    required this.chapter,
    required this.onTap,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Hero(
      tag: 'chapter-${chapter.id}',
      child: Material(
        child: InkWell(
          onTap: () => onTap(chapter),
          child: Card(
            elevation: 2,
            child: Padding(
              padding: EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    chapter.title,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  SizedBox(height: 8),
                  Text(
                    '${chapter.scenes.length} 场景 · ${chapter.wordCount} 字',
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// 章节网格延迟加载
class ChaptersGrid extends StatelessWidget {
  final List<ChapterOutline> chapters;
  final Function(ChapterOutline) onChapterTap;
  
  const ChaptersGrid({
    Key? key,
    required this.chapters,
    required this.onChapterTap,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final crossAxisCount = _calculateCrossAxisCount(constraints.maxWidth);
        
        return GridView.builder(
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: 1.5,
            crossAxisSpacing: 12,
            mainAxisSpacing: 12,
          ),
          itemCount: chapters.length,
          padding: EdgeInsets.all(16),
          // 只有可见区域的卡片会被构建
          itemBuilder: (context, index) {
            return ChapterCardWithHero(
              chapter: chapters[index],
              onTap: onChapterTap,
            );
          },
        );
      }
    );
  }
  
  int _calculateCrossAxisCount(double width) {
    if (width < 600) return 1;
    if (width < 900) return 2;
    if (width < 1200) return 3;
    return 4;
  }
}

// 避免不必要的重建
class ChapterProgressIndicator extends StatelessWidget {
  final NovelStructure structure;
  
  const ChapterProgressIndicator({
    Key? key,
    required this.structure,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    // 计算各种状态的数量
    int plannedCount = 0;
    int inProgressCount = 0;
    int completedCount = 0;
    int revisionCount = 0;
    
    for (final chapter in structure.chapters) {
      switch (chapter.status) {
        case ChapterStatus.planned:
          plannedCount++;
          break;
        case ChapterStatus.inProgress:
          inProgressCount++;
          break;
        case ChapterStatus.completed:
          completedCount++;
          break;
        case ChapterStatus.revision:
          revisionCount++;
          break;
      }
    }
    
    final totalCount = structure.chapters.length;
    
    // 使用CustomPainter而不是多个Widget
    return SizedBox(
      height: 48,
      child: CustomPaint(
        painter: ProgressBarPainter(
          plannedRatio: totalCount > 0 ? plannedCount / totalCount : 0,
          inProgressRatio: totalCount > 0 ? inProgressCount / totalCount : 0,
          completedRatio: totalCount > 0 ? completedCount / totalCount : 0,
          revisionRatio: totalCount > 0 ? revisionCount / totalCount : 0,
        ),
        child: Center(
          child: Text(
            '${completedCount}/${totalCount} 已完成',
            style: TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              shadows: [
                Shadow(
                  color: Colors.black38,
                  offset: Offset(1, 1),
                  blurRadius: 2,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// 自定义进度条绘制器
class ProgressBarPainter extends CustomPainter {
  final double plannedRatio;
  final double inProgressRatio;
  final double completedRatio;
  final double revisionRatio;
  
  ProgressBarPainter({
    required this.plannedRatio,
    required this.inProgressRatio,
    required this.completedRatio,
    required this.revisionRatio,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final rect = Offset.zero & size;
    
    // 背景
    final bgPaint = Paint()
      ..color = Colors.grey.shade300
      ..style = PaintingStyle.fill;
    canvas.drawRRect(
      RRect.fromRectAndRadius(rect, Radius.circular(8)),
      bgPaint,
    );
    
    double startX = 0;
    
    // 已完成部分
    if (completedRatio > 0) {
      final completedPaint = Paint()
        ..color = Colors.green
        ..style = PaintingStyle.fill;
      final completedRect = Rect.fromLTRB(
        startX,
        0,
        startX + size.width * completedRatio,
        size.height,
      );
      canvas.drawRRect(
        RRect.fromRectAndCorners(
          completedRect,
          topLeft: startX == 0 ? Radius.circular(8) : Radius.zero,
          bottomLeft: startX == 0 ? Radius.circular(8) : Radius.zero,
          topRight: Radius.zero,
          bottomRight: Radius.zero,
        ),
        completedPaint,
      );
      startX += size.width * completedRatio;
    }
    
    // 进行中部分
    if (inProgressRatio > 0) {
      final inProgressPaint = Paint()
        ..color = Colors.blue
        ..style = PaintingStyle.fill;
      final inProgressRect = Rect.fromLTRB(
        startX,
        0,
        startX + size.width * inProgressRatio,
        size.height,
      );
      canvas.drawRect(inProgressRect, inProgressPaint);
      startX += size.width * inProgressRatio;
    }
    
    // 修订中部分
    if (revisionRatio > 0) {
      final revisionPaint = Paint()
        ..color = Colors.orange
        ..style = PaintingStyle.fill;
      final revisionRect = Rect.fromLTRB(
        startX,
        0,
        startX + size.width * revisionRatio,
        size.height,
      );
      canvas.drawRect(revisionRect, revisionPaint);
      startX += size.width * revisionRatio;
    }
    
    // 计划中部分不需要绘制，已经有背景色
    
    // 添加边框
    final borderPaint = Paint()
      ..color = Colors.grey.shade400
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;
    canvas.drawRRect(
      RRect.fromRectAndRadius(rect, Radius.circular(8)),
      borderPaint,
    );
  }
  
  @override
  bool shouldRepaint(ProgressBarPainter oldDelegate) {
    return oldDelegate.plannedRatio != plannedRatio ||
           oldDelegate.inProgressRatio != inProgressRatio ||
           oldDelegate.completedRatio != completedRatio ||
           oldDelegate.revisionRatio != revisionRatio;
  }
}
```

### 8. 辅助功能与无障碍支持

```dart
// 为可拖动项添加语义标签
class DraggableChapterItem extends StatelessWidget {
  final ChapterOutline chapter;
  final Widget child;
  
  const DraggableChapterItem({
    Key? key,
    required this.chapter,
    required this.child,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Semantics(
      label: '章节${chapter.order}: ${chapter.title}',
      hint: '拖动可重新排序，包含${chapter.scenes.length}个场景，${chapter.wordCount}字',
      button: true,
      enabled: true,
      onTapHint: '查看章节详情',
      movable: true,
      child: MergeSemantics(
        child: child,
      ),
    );
  }
}

// 章节状态指示器带语义
class AccessibleStatusIndicator extends StatelessWidget {
  final ChapterStatus status;
  
  const AccessibleStatusIndicator({
    Key? key,
    required this.status,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    Color color;
    String label;
    
    switch (status) {
      case ChapterStatus.planned:
        color = Colors.grey;
        label = '计划中';
        break;
      case ChapterStatus.inProgress:
        color = Colors.blue;
        label = '进行中';
        break;
      case ChapterStatus.completed:
        color = Colors.green;
        label = '已完成';
        break;
      case ChapterStatus.revision:
        color = Colors.orange;
        label = '修订中';
        break;
    }
    
    return Semantics(
      label: '章节状态: $label',
      child: Container(
        padding: EdgeInsets.symmetric(horizontal: 8, vertical: 2),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: color),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: color,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}
```

