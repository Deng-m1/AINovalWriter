# Editor Refactoring: Act-Focused Loading and Navigation

## 1. Introduction

### 1.1 Current Challenges
 现在编辑器EditorMainArea组件，在卷之间跳转，都会重新初始化，相关逻辑，但是由此引发了不少跨卷检查引发的问题和性能损耗，我现在想重构这个组件，以卷作为单位，这样就避免了不必要的跨卷判断，而且每次卷跳转都相当于全局当前卷的初始化，这样后端的分页获取的接口，也要重构，
  虚拟化、滚动加载和分页等这些是应对大量场景和章节内容的，不要去掉，获取小说结构统一用editorRepository.getNovelWithSceneSummaries方法，这个可以是这个卷编辑器的一个父组件用的初始化方法，这样就不用每次切换卷就要调用这个函数，实际后端需要修改的接口只用修改分页请求逻辑，就是不用跨卷返回章节了
  同时接口尽量在原有接口上修改，避免产生多余的接口
The current editor architecture, while robust for handling large amounts of content through virtualization and pagination, faces complexities when managing content across multiple "Acts" (volumes). This includes intricate state management for visible elements, performance overhead from frequent calculations, and challenging boundary condition logic for inter-Act navigation.

### 1.2 Refactoring Objectives

This refactoring aims to streamline editor functionality by adopting an "Act-Focused" loading and navigation model. The primary goals are:

*   **Simplified State Management**: The editor primarily concerns itself with the content of the currently active Act.
*   **Optimized Performance**: Reduce unnecessary computations and rendering by loading and managing Act-specific data.
*   **Clearer Navigation**: Implement unambiguous and maintainable logic for transitioning between Acts.
*   **Preserve Intra-Act Efficiency**: Retain virtualization, scrolling, and pagination mechanisms for handling large numbers of chapters and scenes *within* the active Act.
*   **Focused Backend API Modifications**: Adapt existing backend pagination to operate within Act boundaries rather than across the entire novel.

## 2. Core Concepts

### 2.1. Initial Full Structure Load (Shell Loading)

*   **Mechanism**: Upon entering the editor for a novel, the application will make a single call to `editorRepository.getNovelWithSceneSummaries` (backed by the existing `POST /api/v1/novels/get-with-scene-summaries` endpoint).
*   **Data Retrieved**: This call fetches the complete structural metadata of the novel:
    *   All Acts (ID, title, order).
    *   All Chapters (ID, title, order, parent Act ID).
    *   All Scenes (ID, title, order, parent Chapter ID, **and their summaries**).
*   **Management**: This comprehensive `NovelStructure` is held by a higher-level controller (e.g., `EditorScreenController`) and is accessible to components like the navigation sidebar or for determining inter-Act navigation paths.

### 2.2. Active Act Focus

*   **State**: The `EditorBloc` will maintain an `activeActId` to denote the currently focused Act.
*   **Content Loading**: When an Act becomes active, `EditorBloc` is responsible for loading the **full content (including complete scene text)** for the chapters within that Act. This loading can be paginated if an Act itself contains a very large number of chapters.

### 2.3. Intra-Act Virtualization & Pagination

*   **Rendering**: The `EditorMainArea` component, when displaying the `activeActId`, will continue to use virtualization techniques (e.g., `ListView.builder`, `SliverList`) for its chapters and scenes. This ensures that only visible and preloaded elements are rendered, maintaining UI performance even if an Act contains many chapters/scenes.
*   **Data Source**: The data for this virtualization comes from the `currentActFullContent` (or a paginated subset of it) held in the `EditorBloc`'s state.

### 2.4. Inter-Act Navigation

*   **Trigger**: Users navigate between Acts using `VolumeNavigationButtons` or by scrolling to the logical boundaries of the currently loaded content within an Act (if all its chapters are loaded).
*   **Process**:
    1.  A navigation event (e.g., `NavigateToPreviousAct`, `NavigateToNextAct`) is dispatched to `EditorBloc`.
    2.  `EditorBloc` determines the target `actId` using the `NovelStructure`.
    3.  `EditorBloc` then dispatches a `LoadActContent` event for the target `actId`.
    4.  During the loading of the new Act, resources for the previous Act (like `QuillController` instances) are cleared.

## 3. Frontend Refactoring Plan

### 3.1. `EditorBloc` (State & Events)

#### 3.1.1. `EditorState` (`EditorLoaded`)

The `EditorLoaded` state will be adapted to hold both the overall novel structure and the detailed content of the active Act.

```dart
// File: AINoval/lib/blocs/editor/editor_state.dart

part of 'editor_bloc.dart';

// ... (EditorState and other states like EditorInitial, EditorLoading)

class EditorLoaded extends EditorState {
  // Full novel structure with IDs, titles, order for Acts/Chapters, and Scene summaries.
  // This is loaded once initially.
  final novel_models.Novel novelStructure;

  // Detailed content of the currently active Act.
  // Chapters in this Act will have their scenes fully loaded (or paginated).
  // Can be null if no Act is active or content is being switched.
  final novel_models.Act? currentActFullContent;

  final EditorSettings settings;
  final String? activeActId;       // ID of the currently active (viewing/editing) Act
  final String? activeChapterId;   // Active chapter within currentActFullContent
  final String? activeSceneId;     // Active scene within currentActFullContent
  final String? focusChapterId;    // Chapter in viewport focus within currentActFullContent

  final bool isLoadingNovelStructure; // True when fetching the initial novelStructure
  final bool isLoadingActContent;     // True when fetching/paginating currentActFullContent
  final bool isSaving;
  final DateTime? lastSaveTime;
  final String? errorMessage;

  // Flags indicating if the activeActId is the first/last in the novelStructure
  final bool isFirstActInNovel;
  final bool isLastActInNovel;

  // Pagination status for chapters *within* the currentActFullContent
  final bool currentActHasReachedStartOfChapters; // All chapters from the start of currentActFullContent are loaded
  final bool currentActHasReachedEndOfChapters;   // All chapters till the end of currentActFullContent are loaded

  const EditorLoaded({
    required this.novelStructure,
    this.currentActFullContent,
    required this.settings,
    this.activeActId,
    this.activeChapterId,
    this.activeSceneId,
    this.focusChapterId,
    this.isLoadingNovelStructure = false,
    this.isLoadingActContent = false,
    this.isSaving = false,
    this.lastSaveTime,
    this.errorMessage,
    this.isFirstActInNovel = false,
    this.isLastActInNovel = false,
    this.currentActHasReachedStartOfChapters = false,
    this.currentActHasReachedEndOfChapters = false,
  });

  @override
  List<Object?> get props => [
        novelStructure.id, novelStructure.acts.length, // Key identifiers for structure
        currentActFullContent, // Compare the whole Act object
        settings, activeActId, activeChapterId, activeSceneId, focusChapterId,
        isLoadingNovelStructure, isLoadingActContent, isSaving, lastSaveTime, errorMessage,
        isFirstActInNovel, isLastActInNovel,
        currentActHasReachedStartOfChapters, currentActHasReachedEndOfChapters,
      ];

  EditorLoaded copyWith({
    novel_models.Novel? novelStructure,
    ValueGetter<novel_models.Act?>? currentActFullContent, // Use ValueGetter for nullable
    EditorSettings? settings,
    String? activeActId,
    String? activeChapterId,
    String? activeSceneId,
    String? focusChapterId,
    bool? isLoadingNovelStructure,
    bool? isLoadingActContent,
    bool? isSaving,
    DateTime? lastSaveTime,
    String? errorMessage, // Allow clearing
    bool? isFirstActInNovel,
    bool? isLastActInNovel,
    bool? currentActHasReachedStartOfChapters,
    bool? currentActHasReachedEndOfChapters,
  }) {
    return EditorLoaded(
      novelStructure: novelStructure ?? this.novelStructure,
      currentActFullContent: currentActFullContent != null ? currentActFullContent() : this.currentActFullContent,
      settings: settings ?? this.settings,
      activeActId: activeActId ?? this.activeActId,
      activeChapterId: activeChapterId ?? this.activeChapterId,
      activeSceneId: activeSceneId ?? this.activeSceneId,
      focusChapterId: focusChapterId ?? this.focusChapterId,
      isLoadingNovelStructure: isLoadingNovelStructure ?? this.isLoadingNovelStructure,
      isLoadingActContent: isLoadingActContent ?? this.isLoadingActContent,
      isSaving: isSaving ?? this.isSaving,
      lastSaveTime: lastSaveTime ?? this.lastSaveTime,
      errorMessage: errorMessage,
      isFirstActInNovel: isFirstActInNovel ?? this.isFirstActInNovel,
      isLastActInNovel: isLastActInNovel ?? this.isLastActInNovel,
      currentActHasReachedStartOfChapters: currentActHasReachedStartOfChapters ?? this.currentActHasReachedStartOfChapters,
      currentActHasReachedEndOfChapters: currentActHasReachedEndOfChapters ?? this.currentActHasReachedEndOfChapters,
    );
  }
}
```

#### 3.1.2. `EditorEvent`

Key event changes:

```dart
// File: AINoval/lib/blocs/editor/editor_event.dart

part of 'editor_bloc.dart';

// Initial event to load the entire novel's structural metadata and scene summaries
class LoadInitialNovelStructure extends EditorEvent {
  final String novelId;
  // Optional: ID of the Act to load full content for immediately after structure load
  final String? initialActIdToLoadContent;

  const LoadInitialNovelStructure({required this.novelId, this.initialActIdToLoadContent});

  @override
  List<Object?> get props => [novelId, initialActIdToLoadContent];
}

// Event to load (or paginate) the full content of a specific Act's chapters and scenes
class LoadActContent extends EditorEvent {
  final String novelId;
  final String actId; // The Act whose content is to be loaded
  // Optional: For pagination within the Act. If null, load initial set of chapters for the Act.
  final String? fromChapterId;
  final String? direction; // "up" or "down" for pagination within the Act
  final int chaptersLimit; // How many chapters to load in this batch for the Act

  const LoadActContent({
    required this.novelId,
    required this.actId,
    this.fromChapterId,
    this.direction,
    this.chaptersLimit = 5, // Default chapters to load per batch within an Act
  });

  @override
  List<Object?> get props => [novelId, actId, fromChapterId, direction, chaptersLimit];
}

// Event to navigate to the previous Act
class NavigateToPreviousAct extends EditorEvent {
  final String novelId;
  final String currentActId; // Used to determine which Act is previous

  const NavigateToPreviousAct({required this.novelId, required this.currentActId});
  @override
  List<Object?> get props => [novelId, currentActId];
}

// Event to navigate to the next Act
class NavigateToNextAct extends EditorEvent {
  final String novelId;
  final String currentActId; // Used to determine which Act is next

  const NavigateToNextAct({required this.novelId, required this.currentActId});
  @override
  List<Object?> get props => [novelId, currentActId];
}

// CRUD events (UpdateSceneContent, AddNewScene, etc.) remain largely the same,
// but their internal logic will now target `currentActFullContent`.
// The `LoadMoreScenes` event is effectively replaced/subsumed by `LoadActContent` with pagination params.
```

#### 3.1.3. `EditorBloc` Logic Modifications

*   **`_onLoadInitialNovelStructure`**:
    1.  Set state: `emit(EditorLoaded(isLoadingNovelStructure: true, ...))` (with empty `novelStructure`).
    2.  Call `repository.getNovelWithSceneSummaries(event.novelId)` to get `loadedNovelStructure`.
    3.  Determine `initialActId`: Use `event.initialActIdToLoadContent`, or find based on `loadedNovelStructure.lastEditedChapterId`, or default to the first Act in `loadedNovelStructure`.
    4.  Emit state: `emit(EditorLoaded(novelStructure: loadedNovelStructure, activeActId: initialActId, isLoadingNovelStructure: false, ...))`.
    5.  Trigger loading of the initial Act's content: `add(LoadActContent(novelId: event.novelId, actId: initialActId))`.

*   **`_onLoadActContent` (Core logic for loading/paginating an Act's content)**:
    1.  `final currentState = state as EditorLoaded;`
    2.  If `event.actId` is different from `currentState.activeActId` (i.e., switching Acts):
        *   `emit(currentState.copyWith(isLoadingActContent: true, activeActId: event.actId, currentActFullContent: () => null, activeChapterId: null, activeSceneId: null, focusChapterId: null))`. This clears the old Act's content.
    3.  Else (paginating within the same Act):
        *   `emit(currentState.copyWith(isLoadingActContent: true))`.
    4.  Determine `isFirstActInNovel` and `isLastActInNovel` from `currentState.novelStructure` and `event.actId`.
    5.  Call `repository.loadMoreScenes(...)` (the modified backend endpoint):
        *   Pass `novelId: event.novelId`, `actId: event.actId`.
        *   Pass `fromChapterId: event.fromChapterId`, `direction: event.direction`, `chaptersLimit: event.chaptersLimit` for pagination within the Act.
        *   If `event.fromChapterId` is null, it implies loading the initial batch of chapters for `event.actId`.
    6.  The backend responds with a `Map<String, List<novel_models.Scene>> loadedChaptersWithScenes` and potentially boundary flags for the *Act*. For simplicity, we'll derive boundary flags on the frontend.
    7.  Merge `loadedChaptersWithScenes` into `currentState.currentActFullContent` (if paginating) or create a new `novel_models.Act` object (if loading a new Act).
        *   If `event.actId` changed, the new `currentActFullContent` will be based on the `actId`'s metadata from `novelStructure` and the `loadedChaptersWithScenes`.
        *   If paginating, append/prepend `loadedChaptersWithScenes` to `currentState.currentActFullContent.chapters`.
    8.  Determine `currentActHasReachedStartOfChapters` and `currentActHasReachedEndOfChapters` by comparing the loaded chapter IDs against the full list of chapter IDs for `event.actId` (available in `currentState.novelStructure`).
    9.  `emit(currentState.copyWith(isLoadingActContent: false, currentActFullContent: () => newOrUpdatedActContent, isFirstActInNovel: ..., isLastActInNovel: ..., currentActHasReachedStartOfChapters: ..., currentActHasReachedEndOfChapters: ...))`.
    10. Set `activeChapterId` / `activeSceneId` (e.g., to the first chapter/scene of the newly loaded batch, or maintain existing focus if just paginating).

*   **`_onNavigateToPreviousAct` / `_onNavigateToNextAct`**:
    1.  `final currentState = state as EditorLoaded;`
    2.  Use `currentState.novelStructure` and `event.currentActId` to find the `previousActId` or `nextActId`.
    3.  If found, `add(LoadActContent(novelId: event.novelId, actId: newActId))`. // Default to loading initial batch of new Act

*   **CRUD Operations (e.g., `_onUpdateSceneContent`, `_onAddNewScene`)**:
    1.  Operations primarily modify `currentState.currentActFullContent`.
    2.  After calling repository methods for persistence, ensure `currentState.novelStructure` (specifically scene summaries or chapter/act titles) is also updated if the CRUD operation affects them.
    3.  `emit(currentState.copyWith(currentActFullContent: () => updatedActContent, novelStructure: updatedNovelStructureIfNeeded, ...))`.

### 3.2. `EditorScreenController`

*   **`novelStructure` Property**: Holds `(state as EditorLoaded).novelStructure`. Passed down or accessed via `context.watch`.
*   **`currentActContent` Property**: Holds `(state as EditorLoaded).currentActFullContent`.
*   **Resource Management**:
    *   `ensureControllersForAct(novel_models.Act actContent)`: Called when `currentActFullContent` changes in BLoC state. Iterates through `actContent.chapters` and their `scenes` to create/update `QuillController`s, etc.
    *   `clearControllersForAct(String actId)`: Called when `activeActId` changes, to dispose of controllers associated with the *previous* `actId`.
*   **Scroll Handling**:
    *   The `scrollController` (passed to `EditorMainArea`) is monitored.
    *   If scroll reaches near the top/bottom of the *currently rendered chapters within the active Act*, and `EditorLoaded.currentActHasReachedStartOfChapters` / `currentActHasReachedEndOfChapters` is `false`, then dispatch `LoadActContent` event with appropriate `fromChapterId` and `direction` for *intra-Act pagination*.
*   **`createNewAct()`**: Dispatches `AddNewAct` to BLoC. BLoC handles persistence and then triggers `LoadActContent` for the new (empty) Act.

### 3.3. `EditorMainArea`

*   **Props**: Receives `novelStructure` and `currentActFullContent` from `EditorBloc` state (likely via `BlocBuilder`).
*   **Build Logic (`_buildActView`)**:
    *   If `currentActFullContent` is null or `isLoadingActContent` (and no chapters yet), display loading indicator.
    *   Renders the `ActSectionHeader` (title, etc.) using `currentActFullContent` and `novelStructure` (for total chapter count in this Act).
    *   Uses `ListView.builder` or `CustomScrollView` + `SliverList` to render `ChapterSection` components from `currentActFullContent.chapters`. This provides **intra-Act virtualization**.
        *   The `itemCount` for this list will be `currentActFullContent.chapters.length` plus one if `isLoadingActContent` and not yet at end-of-act-chapters.
    *   The scroll listener (forwarded from `EditorScreenController` or local) triggers `LoadActContent` for intra-Act pagination when near boundaries of loaded chapters *within* the `currentActFullContent`.
*   **`VolumeNavigationButtons`**:
    *   `isFirstAct` / `isLastAct` determined by `EditorLoaded.isFirstActInNovel` / `isLastActInNovel`.
    *   `onPreviousAct` dispatches `NavigateToPreviousAct`.
    *   `onNextAct` dispatches `NavigateToNextAct`.
    *   `onAddNewAct` (if `isLastActInNovel` is true) calls `editorScreenController.createNewAct()`.

```dart
// File: AINoval/lib/screens/editor/components/editor_main_area.dart (Conceptual Snippet)

// State variable for VolumeNavigationButtons loading indicator
String? _interActNavigationDirection; // 'up' or 'down'

Widget build(BuildContext context) {
  return BlocBuilder<editor_bloc.EditorBloc, editor_bloc.EditorState>(
    builder: (context, state) {
      if (state is! editor_bloc.EditorLoaded || state.isLoadingNovelStructure) {
        return Center(child: CircularProgressIndicator(key: Key("novel_structure_loading")));
      }

      final editorScreenController = Provider.of<EditorScreenController>(context, listen: false);

      // This should ideally be managed by EditorScreenController based on BLoC state changes
      if (state.currentActFullContent != null) {
         // editorScreenController.ensureControllersForAct(state.currentActFullContent!);
      }

      return Column(
        children: [
          VolumeNavigationButtons(
            isTop: true,
            isFirstAct: state.isFirstActInNovel,
            isLastAct: false, // Top button doesn't care about last Act
            isLoadingMore: state.isLoadingActContent && _interActNavigationDirection == 'up',
            previousActTitle: _getActTitle(state.novelStructure, state.activeActId, -1),
            onPreviousAct: state.isFirstActInNovel ? null : () {
              setState(() => _interActNavigationDirection = 'up');
              widget.editorBloc.add(editor_bloc.NavigateToPreviousAct(
                novelId: widget.editorBloc.novelId,
                currentActId: state.activeActId!,
              ));
            },
          ),
          Expanded(
            child: (state.currentActFullContent == null || (state.isLoadingActContent && state.currentActFullContent!.chapters.isEmpty))
                ? Center(child: CircularProgressIndicator(key: Key("act_content_display_loading")))
                : NotificationListener<ScrollNotification>(
                    onNotification: (notification) {
                      // Pass state to scroll handler for boundary checks
                      _handleIntraActScroll(notification, state);
                      return false;
                    },
                    child: CustomScrollView(
                      controller: widget.scrollController,
                      key: ValueKey(state.activeActId), // Ensure rebuild on Act change
                      slivers: [
                        SliverToBoxAdapter(
                          child: ActSectionHeaderWidget( // A new stateless widget
                            actTitle: state.currentActFullContent!.title,
                            totalChaptersInAct: state.novelStructure.acts
                                .firstWhereOrNull((a) => a.id == state.activeActId)
                                ?.chapters.length ?? 0,
                            loadedChaptersInAct: state.currentActFullContent!.chapters.length,
                            // ... other props ...
                          ),
                        ),
                        SliverList(
                          delegate: SliverChildBuilderDelegate(
                            (context, index) {
                              final chapters = state.currentActFullContent!.chapters;
                              if (index >= chapters.length) {
                                // Show loading indicator for intra-Act pagination
                                if (state.isLoadingActContent && !state.currentActHasReachedEndOfChapters) {
                                  return const Center(child: Padding(
                                    padding: EdgeInsets.all(16.0),
                                    child: CircularProgressIndicator(key: Key("intra_act_pagination_loading")),
                                  ));
                                }
                                return null; // Should not happen if itemCount is correct
                              }
                              final chapter = chapters[index];
                              // ... build ChapterSection ...
                              // SceneEditors will use controllers from EditorScreenController
                              // Ensure SceneEditor keys are unique: ValueKey('scene_${state.activeActId}_${chapter.id}_${scene.id}')
                              return ChapterSection(
                                  key: ValueKey('chapter_${state.activeActId}_${chapter.id}'),
                                  // ...props...
                                  scenes: chapter.scenes.map((scene) => SceneEditor(
                                      key: ValueKey('scene_${state.activeActId}_${chapter.id}_${scene.id}'),
                                      controller: editorScreenController.sceneControllers['${state.activeActId}_${chapter.id}_${scene.id}'] ?? _createErrorController(),
                                      summaryController: editorScreenController.sceneSummaryControllers['${state.activeActId}_${chapter.id}_${scene.id}'] ?? TextEditingController(text:"Error"),
                                      // ... other scene props ...
                                      isActive: scene.id == state.activeSceneId,
                                      editorBloc: widget.editorBloc,
                                      actId: state.activeActId,
                                      chapterId: chapter.id,
                                      sceneId: scene.id,
                                      title: scene.title ?? "Scene",
                                      wordCount: (scene.wordCount ?? 0).toString(),
                                  )).toList(),
                                  editorBloc: widget.editorBloc,
                                  actId: state.activeActId!,
                                  chapterId: chapter.id,
                                  title: chapter.title
                              );
                            },
                            childCount: state.currentActFullContent!.chapters.length +
                                        ((state.isLoadingActContent && !state.currentActHasReachedEndOfChapters) ? 1 : 0),
                          ),
                        ),
                        if (state.isLastActInNovel)
                          SliverToBoxAdapter(child: AddActButton()),
                      ],
                    ),
                  ),
          ),
          VolumeNavigationButtons(
            isTop: false,
            isFirstAct: false,
            isLastAct: state.isLastActInNovel,
            isLoadingMore: state.isLoadingActContent && _interActNavigationDirection == 'down',
            nextActTitle: _getActTitle(state.novelStructure, state.activeActId, 1),
            onNextAct: state.isLastActInNovel ? null : () {
              setState(() => _interActNavigationDirection = 'down');
              widget.editorBloc.add(editor_bloc.NavigateToNextAct(
                novelId: widget.editorBloc.novelId,
                currentActId: state.activeActId!,
              ));
            },
            onAddNewAct: state.isLastActInNovel
                ? () => Provider.of<EditorScreenController>(context, listen: false).createNewAct()
                : null,
          ),
        ],
      );
    },
  );
}

// Helper to get adjacent Act titles for navigation buttons
String? _getActTitle(novel_models.Novel structure, String? currentActId, int offset) {
    if (currentActId == null || structure.acts.isEmpty) return null;
    final currentIndex = structure.acts.indexWhere((act) => act.id == currentActId);
    if (currentIndex == -1) return null;
    final targetIndex = currentIndex + offset;
    if (targetIndex >= 0 && targetIndex < structure.acts.length) {
        return structure.acts[targetIndex].title;
    }
    return null;
}

QuillController _createErrorController() => QuillController(document: Document()..insert(0,"Error controller"), selection: TextSelection.collapsed(offset: 0));


void _handleIntraActScroll(ScrollNotification notification, editor_bloc.EditorLoaded currentState) {
  if (notification is ScrollEndNotification && // More robust check might be needed
      currentState.activeActId != null &&
      currentState.currentActFullContent != null &&
      currentState.currentActFullContent!.chapters.isNotEmpty) {

    final metrics = notification.metrics;
    final editorBloc = widget.editorBloc; // Assuming editorBloc is a widget field

    // Load more downwards (intra-Act)
    if (metrics.extentAfter < 300 && // Threshold to trigger load
        !currentState.isLoadingActContent &&
        !currentState.currentActHasReachedEndOfChapters) {
      editorBloc.add(editor_bloc.LoadActContent(
        novelId: editorBloc.novelId,
        actId: currentState.activeActId!,
        fromChapterId: currentState.currentActFullContent!.chapters.last.id,
        direction: 'down',
        // chaptersLimit: 5, // Or from config
      ));
    }
    // Load more upwards (intra-Act)
    else if (metrics.extentBefore < 300 && // Threshold
               !currentState.isLoadingActContent &&
               !currentState.currentActHasReachedStartOfChapters) {
      editorBloc.add(editor_bloc.LoadActContent(
        novelId: editorBloc.novelId,
        actId: currentState.activeActId!,
        fromChapterId: currentState.currentActFullContent!.chapters.first.id,
        direction: 'up',
        // chaptersLimit: 5,
      ));
    }
  }
}
```

### 3.4. `VolumeNavigationButtons`

*   Props `isFirstAct` and `isLastAct` are driven by `EditorLoaded.isFirstActInNovel` and `EditorLoaded.isLastActInNovel`.
*   `isLoadingMore` prop should indicate if an inter-Act navigation (i.e., `LoadActContent` for a *different* Act) is in progress. This can be a combination of `EditorLoaded.isLoadingActContent` and a local flag in `EditorMainArea` indicating the *direction* of the inter-Act navigation attempt.
*   Callbacks dispatch `NavigateToPreviousAct`, `NavigateToNextAct`, or trigger `EditorScreenController.createNewAct()`.

### 3.5. `ActSection`, `ChapterSection`, `SceneEditor`

*   `ActSection` might be refactored into `ActSectionHeaderWidget` (stateless, displays title and chapter counts from `novelStructure` and `currentActFullContent`) and the list rendering logic within `EditorMainArea`.
*   `ChapterSection` and `SceneEditor` render data from the `currentActFullContent`. Their internal virtualization (if a chapter has too many scenes) is preserved.

## 4. Backend Refactoring Plan

The goal is to adapt existing endpoints for pagination *within an Act*.

### 4.1. API Endpoint Modifications

*   **`POST /api/v1/novels/get-with-scene-summaries` (Existing)**
    *   **No Change Required.** This endpoint already provides the full novel structure with scene summaries, which is ideal for the initial "Shell Load."

*   **`POST /api/v1/novels/load-more-scenes` (Modify Existing)**
    *   **Current Request DTO (`LoadMoreScenesRequestDto`)**: `novelId`, `fromChapterId`, `direction`, `chaptersLimit`.
    *   **Proposed Request DTO Modification**: Add `String actId` (optional, but crucial for this new logic).
        ```java
        // LoadMoreScenesRequestDto.java
        public class LoadMoreScenesRequestDto {
            private String novelId;
            private String actId; // NEW: ID of the Act to paginate within
            private String fromChapterId; // Anchor chapter for pagination
            private String direction;     // "up" or "down" from fromChapterId
            private int chaptersLimit;
            // ... getters and setters ...
        }
        ```
    *   **Current Response**: `Mono<Map<String, List<Scene>>>` (Map of Chapter ID to list of its full Scenes). This response type can be maintained.
    *   **Backend Logic Modification in `NovelServiceImpl.loadMoreScenes`**:
        1.  If `actId` is provided in the request:
            *   The service must first fetch the specified `Act` from the `Novel`.
            *   All chapter lookups (`fromChapterId`) and subsequent pagination (`direction`, `chaptersLimit`) **must be constrained to only the chapters belonging to this `actId`**. The method should not return chapters from other Acts.
            *   If `fromChapterId` is null (and `actId` is provided), it implies loading the initial `chaptersLimit` chapters *of that specific Act*.
        2.  If `actId` is NOT provided:
            *   The endpoint can retain its original behavior of potentially loading chapters across Act boundaries (though this behavior will be less used by the refactored frontend for primary content display).
        *   The method should still return `Map<String, List<Scene>>` containing the chapters (with their full scenes) that fall within the requested paginated window *of the specified Act*.

    *   **Boundary Flags**: Instead of the backend returning `hasReachedStartOfAct` / `hasReachedEndOfAct`, the frontend `EditorBloc` will determine these flags. After receiving the `Map<String, List<Scene>>` from this endpoint, the BLoC will compare the IDs of the returned chapters against the complete list of chapter IDs for the `activeActId` (which it knows from `novelStructure`) to deduce if the beginning or end of chapters *within that Act* has been reached.

### 4.2. `NovelController.java`

Update the `@PostMapping("/load-more-scenes")` method to accept the modified `LoadMoreScenesRequestDto` which now includes `actId`.

```java
// File: AINovalServer/src/main/java/com/ainovel/server/web/controller/NovelController.java
// ...
    @PostMapping("/load-more-scenes")
    public Mono<Map<String, List<Scene>>> loadMoreScenes(@RequestBody LoadMoreScenesRequestDto loadMoreScenesRequestDto) {
        // Log the incoming request including the new actId
        log.info("Received loadMoreScenes request for novelId: {}, actId: {}, fromChapterId: {}, direction: {}, limit: {}",
                loadMoreScenesRequestDto.getNovelId(),
                loadMoreScenesRequestDto.getActId(), // Will be null if not sent by client
                loadMoreScenesRequestDto.getFromChapterId(),
                loadMoreScenesRequestDto.getDirection(),
                loadMoreScenesRequestDto.getChaptersLimit());

        return novelService.loadMoreScenes(
                loadMoreScenesRequestDto.getNovelId(),
                loadMoreScenesRequestDto.getActId(), // Pass it to the service
                loadMoreScenesRequestDto.getFromChapterId(),
                loadMoreScenesRequestDto.getDirection(),
                loadMoreScenesRequestDto.getChaptersLimit()
        );
    }
// ...
```

### 4.3. `NovelService.java` and `NovelServiceImpl.java`

Modify the `loadMoreScenes` method signature and implementation:

```java
// File: AINovalServer/src/main/java/com/ainovel/server/service/NovelService.java
public interface NovelService {
    // ... other methods
    Mono<Map<String, List<Scene>>> loadMoreScenes(String novelId, String actId, String fromChapterId, String direction, int chaptersLimit);
}

// File: AINovalServer/src/main/java/com/ainovel/server/service/impl/NovelServiceImpl.java
@Slf4j
@Service
@RequiredArgsConstructor
public class NovelServiceImpl implements NovelService {
    // ... other dependencies (novelRepository, sceneService)

    @Override
    public Mono<Map<String, List<Scene>>> loadMoreScenes(String novelId, String actIdConstraint, String fromChapterId, String direction, int chaptersLimit) {
        return novelRepository.findById(novelId)
            .switchIfEmpty(Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND, "Novel not found: " + novelId)))
            .flatMap(novel -> {
                List<Novel.Chapter> chaptersToConsider = new ArrayList<>();

                if (StringUtils.hasText(actIdConstraint)) {
                    // Constrain to a specific Act
                    Novel.Act targetAct = novel.getActs().stream()
                        .filter(act -> act.getId().equals(actIdConstraint))
                        .findFirst()
                        .orElse(null);
                    if (targetAct == null) {
                        log.warn("ActId constraint {} not found in novel {}", actIdConstraint, novelId);
                        return Mono.just(Collections.emptyMap()); // Or error
                    }
                    chaptersToConsider.addAll(targetAct.getChapters());
                    log.info("Constraining chapter load to Act: {} which has {} chapters", actIdConstraint, chaptersToConsider.size());
                } else {
                    // Original behavior: consider all chapters from all acts
                    novel.getActs().forEach(act -> chaptersToConsider.addAll(act.getChapters()));
                    log.info("No ActId constraint, considering all {} chapters in novel {}", chaptersToConsider.size(), novelId);
                }

                // Sort all chapters to be considered by their absolute order in the novel (or Act if constrained)
                // Assuming Chapter has an 'order' field that is globally unique or unique within its context (Act/Novel)
                // For simplicity, if 'order' is just within an Act, and acts have order, a compound sort is needed.
                // Let's assume chapters have a globally meaningful order or can be derived.
                // If not, a more complex sorting/flattening is needed if actIdConstraint is null.
                // For this refactor, the primary use case is WITH actIdConstraint.
                chaptersToConsider.sort(Comparator.comparingInt(Novel.Chapter::getOrder));


                int anchorIndex = -1;
                if (StringUtils.hasText(fromChapterId)) {
                    for (int i = 0; i < chaptersToConsider.size(); i++) {
                        if (chaptersToConsider.get(i).getId().equals(fromChapterId)) {
                            anchorIndex = i;
                            break;
                        }
                    }
                    if (anchorIndex == -1) {
                        log.warn("fromChapterId {} not found within the considered chapters for novel {}", fromChapterId, novelId);
                        return Mono.just(Collections.emptyMap()); // Or error
                    }
                }

                List<Novel.Chapter> selectedChapters;
                if ("up".equalsIgnoreCase(direction)) {
                    int endIndex = (anchorIndex != -1) ? anchorIndex : chaptersToConsider.size();
                    int startIndex = Math.max(0, endIndex - chaptersLimit);
                    selectedChapters = chaptersToConsider.subList(startIndex, endIndex);
                } else if ("down".equalsIgnoreCase(direction)) {
                    int startIndex = (anchorIndex != -1) ? anchorIndex + 1 : 0;
                    int endIndex = Math.min(chaptersToConsider.size(), startIndex + chaptersLimit);
                    selectedChapters = chaptersToConsider.subList(startIndex, endIndex);
                } else { // "center" or fromChapterId is null (load initial batch for the Act)
                    if (anchorIndex != -1) { // Centered around fromChapterId
                        int halfLimit = chaptersLimit / 2;
                        int startIndex = Math.max(0, anchorIndex - halfLimit);
                        // Adjust endIndex to try and get chaptersLimit total, respecting bounds
                        int endIndex = Math.min(chaptersToConsider.size(), startIndex + chaptersLimit);
                        // If startIndex was pushed to 0, endIndex might be too large, readjust
                        if (startIndex == 0) {
                             endIndex = Math.min(chaptersToConsider.size(), chaptersLimit);
                        }
                        selectedChapters = chaptersToConsider.subList(startIndex, endIndex);
                    } else { // fromChapterId is null, load initial batch for the Act (if actIdConstraint is present) or novel
                        selectedChapters = chaptersToConsider.subList(0, Math.min(chaptersToConsider.size(), chaptersLimit));
                    }
                }
                
                log.info("Selected {} chapters to load full content for novel {}, actIdConstraint {}", selectedChapters.size(), novelId, actIdConstraint);


                if (selectedChapters.isEmpty()) {
                    return Mono.just(Collections.emptyMap());
                }

                // For each selected chapter, fetch its full scenes
                Map<String, Mono<List<Scene>>> scenesByChapterIdMonoMap = selectedChapters.stream()
                    .collect(Collectors.toMap(
                        Novel.Chapter::getId,
                        chapter -> sceneService.findScenesByChapterIdOrdered(chapter.getId()).collectList()
                    ));

                // Combine the Monos into a Mono<Map<String, List<Scene>>>
                List<String> chapterIds = new ArrayList<>(scenesByChapterIdMonoMap.keySet());
                List<Mono<List<Scene>>> sceneMonos = new ArrayList<>(scenesByChapterIdMonoMap.values());

                return Flux.zip(
                        Flux.fromIterable(sceneMonos), // Flux of Mono<List<Scene>>
                        sourceLists -> { // This function takes an array of List<Scene>
                            Map<String, List<Scene>> resultMap = new LinkedHashMap<>(); // Maintain order
                            for (int i = 0; i < sourceLists.length; i++) {
                                // Assuming sourceLists[i] is List<Scene>
                                resultMap.put(chapterIds.get(i), (List<Scene>) sourceLists[i]);
                            }
                            return resultMap;
                        },
                        sceneMonos.toArray(new Mono[0]) // Pass the Monos as varargs
                ).next(); // Convert Flux<Map> to Mono<Map>
            });
    }
    // ... rest of the NovelServiceImpl
}
```
**Note on `Flux.zip` usage**: The `Flux.zip` example above is a bit convoluted for combining a map of Monos. A more straightforward way to combine a `Map<String, Mono<List<Scene>>>` into `Mono<Map<String, List<Scene>>>` would be:

```java
// Inside flatMap after selectedChapters logic:
Map<String, Mono<List<Scene>>> scenesByChapterIdMonoMap = ...;

if (scenesByChapterIdMonoMap.isEmpty()) {
    return Mono.just(Collections.emptyMap());
}

// Get all Monos
List<Mono<Tuple2<String, List<Scene>>>> tupleMonos = scenesByChapterIdMonoMap.entrySet().stream()
    .map(entry -> entry.getValue().map(scenes -> Tuples.of(entry.getKey(), scenes)))
    .collect(Collectors.toList());

return Flux.merge(tupleMonos) // Merge will interleave, use concat if order of chapters matters here
    .collectMap(Tuple2::getT1, Tuple2::getT2);
```
Or even more directly if the order of chapters in the response map matters and should match `selectedChapters`:
```java
List<Mono<ChapterWithScenes>> chapterWithScenesMonos = selectedChapters.stream()
    .map(ch -> sceneService.findScenesByChapterIdOrdered(ch.getId())
        .collectList()
        .map(sc -> new ChapterWithScenes(ch.getId(), sc)))
    .collect(Collectors.toList());

return Flux.concat(chapterWithScenesMonos) // Use concat to preserve order of selectedChapters
    .collectMap(ChapterWithScenes::getChapterId, ChapterWithScenes::getScenes, LinkedHashMap::new);
// Helper class
// static class ChapterWithScenes { String chapterId; List<Scene> scenes; /* constructor, getters */ }
```

This revised `loadMoreScenes` implementation ensures that if an `actIdConstraint` is provided, pagination is strictly limited to that Act's chapters.

## 5. Data Models (Dart)

*   **`NovelStructure`**: This isn't a new explicit model but refers to the `novel_models.Novel` object returned by `getNovelWithSceneSummaries`, where Acts and Chapters primarily contain metadata and Scenes contain summaries.
*   **`CurrentActFullContent`**: This is represented by `novel_models.Act` within `EditorLoaded` state, where its `chapters` list contains `novel_models.Chapter` objects, and these Chapter objects contain a list of *fully loaded* `novel_models.Scene` objects (with `content`).
*   No new top-level Dart models are strictly required if the frontend BLoC can derive boundary conditions from the `Map<String, List<Scene>>` and `NovelStructure`.

## 6. Refactoring Steps

1.  **Backend API Modification**:
    *   Modify `LoadMoreScenesRequestDto.java` to include `actId`.
    *   Update `NovelController.loadMoreScenes` to use the modified DTO.
    *   Crucially, refactor `NovelServiceImpl.loadMoreScenes` to respect the `actIdConstraint` for chapter selection and pagination. Ensure it does not return chapters outside the specified `actId`.
    *   Thoroughly test the modified `/load-more-scenes` endpoint, especially with the `actId` parameter.
2.  **Repository Layer (Dart)**:
    *   Update the `editorRepository.loadMoreScenes` method signature in Dart to accept the optional `actId` parameter and pass it in the API call.
3.  **BLoC Layer (Dart)**:
    *   Implement `EditorState` (`EditorLoaded`) as defined, including `novelStructure` and `currentActFullContent`.
    *   Implement `EditorEvent`s: `LoadInitialNovelStructure`, `LoadActContent`, `NavigateToPreviousAct`, `NavigateToNextAct`.
    *   Implement the BLoC event handlers:
        *   `_onLoadInitialNovelStructure`: Fetches full structure, then triggers `LoadActContent` for the initial Act.
        *   `_onLoadActContent`: Calls modified `repository.loadMoreScenes` (passing `actId`). Manages `currentActFullContent`, determines `isFirst/LastActInNovel`, and derives `currentActHasReachedStart/EndOfChapters` based on returned chapters vs `novelStructure`.
        *   `_onNavigateTo...`: Determines target `actId` from `novelStructure` and dispatches `LoadActContent`.
        *   Update CRUD event handlers to modify `currentActFullContent` and sync metadata changes to `novelStructure`.
4.  **Controller Layer (Dart - `EditorScreenController`)**:
    *   Adapt to hold/provide `novelStructure` and `currentActFullContent` from BLoC.
    *   Refine controller management (`ensureControllersForAct`, `clearControllersForAct`).
    *   Modify scroll listeners to dispatch `LoadActContent` (with pagination params like `fromChapterId`, `direction`, and the current `activeActId`) for intra-Act pagination.
5.  **UI Layer (Dart - `EditorMainArea`, `VolumeNavigationButtons`, etc.)**:
    *   `EditorMainArea` consumes `novelStructure` (for overall context like Act titles for nav buttons) and `currentActFullContent` (for rendering the active Act's content).
    *   Implement intra-Act virtualization for chapters within `EditorMainArea`.
    *   Connect `VolumeNavigationButtons` to dispatch `NavigateTo...Act` events.
    *   Ensure `ActSectionHeaderWidget` (or similar) displays correct chapter counts.
6.  **Thorough Testing**:
    *   Initial load of novel structure.
    *   Loading content for the first Act.
    *   Navigating between Acts (forward and backward).
    *   Intra-Act pagination (scrolling to load more chapters within a large Act).
    *   CRUD operations and their effect on both `currentActFullContent` and `novelStructure` (summaries/titles).
    *   Edge cases: empty Acts, Acts with few chapters, novel with only one Act.

## 7. Expected Benefits

*   **Reduced Frontend Complexity**: State related to cross-Act visibility and pagination is largely eliminated.
*   **Improved Performance**: More targeted data loading for the active Act. Intra-Act virtualization handles large content within the focused scope.
*   **Maintainability**: Clearer separation of concerns between inter-Act navigation and intra-Act content display.
*   **API Reusability**: Leverages and extends existing backend endpoints with minimal new surface area.

This revised plan maintains the powerful intra-Act virtualization and pagination while simplifying inter-Act transitions by focusing data loading per Act, primarily by making the existing pagination endpoint Act-aware.
