# **小说设定功能后端需求文档 (V1.3 \- 关系、分组与增强RAG)**

## **1\. 概述**

### **1.1. 目标**

为 AINovalWriter 平台引入小说设定管理功能，允许用户创建、编辑、存储和管理其小说的核心设定（世界观、人物、地点、物品、纪年史等），为其设定优先级，定义设定之间的关系，并创建上下文相关的设定组。通过 RAG (检索增强生成) 技术，在 AI 生成场景内容时，智能地检索并利用相关的设定信息（结合语义相关性、用户定义的优先级、关系链接以及上下文设定组），提高生成内容的准确性、一致性和相关性。

### **1.2. 范围**

本需求文档主要关注 **后端** 实现，包括：

* 小说设定条目、设定关系和设定组数据的存储与管理。  
* 设定信息（包括其关系和所属分组）的向量化索引。  
* 基于 LLM 关键词提取和向量相似度检索相关设定，并结合优先级、关系和分组进行结果优化。  
* 提供支持前端设定管理和增强 RAG 检索的 API 接口。

### **1.3. 关键变更点**

* **（承接 V1.2）设定关系管理:** 系统支持用户定义不同小说设定条目之间的关系 (例如：角色A是角色B的父亲，物品X属于角色A)。  
* **新增 \- 上下文设定组 (Contextual Setting Groups):**  
  * 允许用户创建命名的“设定组”，每个组可以包含多个小说设定条目。  
  * 这些组可以被标记为在特定上下文（如特定章节、故事线、场景）中激活，从而在 RAG 检索时优先考虑组内设定。  
* **新增 \- 增强的 RAG 检索逻辑:**  
  * RAG 检索不仅考虑单条设定的相关性，还会利用已定义的设定关系，智能扩展检索范围，获取与初始检索结果直接关联的其他重要设定。  
  * RAG 检索可以根据当前激活的“上下文设定组”来优先或限定检索范围。  
* **数据模型和 API 调整:** 采用新的 NovelSettingItem 实体，并相应调整数据模型以支持设定关系和设定组，并更新 API 接口。

## **2\. 功能需求**

### **2.1. 设定数据管理**

* **数据模型:**  
  * **新增 NovelSettingItem (小说设定条目) 实体** (domain/model/NovelSettingItem.java):  
    * id (String): 唯一标识符。  
    * novelId (String): 关联的小说 ID (建立索引)。  
    * userId (String): 关联的用户 ID。  
    * sceneId (String, 可选): 关联的场景 ID。如果此设定条目是针对特定场景（例如由 AI 为某场景生成），则填充此字段。  
    * type (String): 设定类型枚举 (e.g., "CHARACTER", "LOCATION", "ITEM", "WORLDVIEW", "LORE", "TIMELINE", "FACTION", "CONCEPT") (建立索引)。  
    * name (String): 设定条目的名称 (e.g., 人物名, 地点名) (建立索引)。  
    * content (String/Object): 设定内容。对于结构化数据，可以是 JSON 字符串或嵌套对象；对于非结构化数据，是文本字符串。  
    * attributes (Map\<String, Object\>, 可选): 用于存储结构化设定的键值对 (e.g., 人物卡片的字段)。  
    * priority (Integer): 设定优先级，例如 1 (最高) 到 5 (最低)。默认为中间值 (如 3)。  
    * relationships (List, 可选): 存储与其他小说设定条目的关系。  
      * SettingRelationship 对象包含:  
        * relatedNovelSettingItemId (String): 关联的小说设定条目 ID。  
        * relationshipType (String): 关系类型 (e.g., "父子", "盟友", "敌人", "拥有", "位于", "前置事件", "组成部分")，用户可自定义或选择预定义类型。  
        * description (String, 可选): 关系描述。  
    * generatedBy (String, 可选): 标明设定来源，例如 "USER", "AI\_SCENE\_SUGGESTION", "AI\_GENERAL\_SUGGESTION"。默认为 "USER"。  
    * status (String, 可选): 标明 AI 生成设定的状态，例如 "SUGGESTED", "ACCEPTED", "REJECTED"。仅当 generatedBy 非 "USER" 时有效。  
    * createdAt (Date): 创建时间。  
    * updatedAt (Date): 更新时间。  
  * **新增 SettingGroup 实体:**  
    * id (String): 唯一标识符。  
    * novelId (String): 关联的小说 ID (建立索引)。  
    * userId (String): 关联的用户 ID。  
    * name (String): 设定组名称 (e.g., "第一章关键设定", "黑森林战役角色与物品")。  
    * description (String, 可选): 设定组描述。  
    * novelSettingItemIds (List): 该组包含的小说设定条目 ID 列表。  
    * isActiveContext (Boolean, 可选): 标记该组是否为当前写作上下文的激活组（此状态可能由用户在前端切换，后端存储）。  
    * createdAt (Date): 创建时间。  
    * updatedAt (Date): 更新时间。  
* **CRUD 操作:**  
  * **NovelSettingItem:**  
    * API 请求/响应体需包含 priority、relationships、可选的 sceneId、generatedBy 和 status 字段。  
    * 查询操作应支持按 novelId、sceneId、type、name、priority、generatedBy 等条件进行分页查询和过滤。  
  * **SettingRelationship:**  
    * 提供 API 接口用于在两个小说设定条目之间添加、修改、删除关系。  
  * **SettingGroup:**  
    * 提供 API 接口用于创建、修改、删除设定组。  
    * 提供 API 接口用于向设定组中添加/移除小说设定条目。  
    * 提供 API 接口用于激活/取消激活设定组的上下文状态。  
    * 查询操作应支持按 novelId、name 查询设定组。  
* **权限控制:**  
  * 确保用户只能访问和修改自己拥有的小说的设定条目、关系和设定组。  
* **关于 sceneId 和 AI 生成设定的进一步建议:**  
  * **AI 生成流程:** 当 AI 被要求为特定场景（由 sceneId 标识）生成设定建议时，新创建的 NovelSettingItem 记录应包含此 sceneId，并将 generatedBy 标记为类似 "AI\_SCENE\_SUGGESTION"，status 初始为 "SUGGESTED"。  
  * **用户审核:** 前端应提供界面供用户审核 AI 生成的设定。用户可以接受、拒绝或编辑这些建议。接受后，status 可变为 "ACCEPTED"。  
  * **RAG 利用:**  
    * 在为特定场景检索设定时，与该 sceneId 关联的 NovelSettingItem（尤其是状态为 "ACCEPTED" 或用户创建的）可以获得更高的相关性权重。  
    * 用户创建的设定（generatedBy \= "USER"）通常应具有比 AI 建议的设定更高的默认可信度或优先级，除非用户明确调整。  
  * **独立性与关联性:** 即使设定与特定场景关联（通过 sceneId），它仍然是一个独立的设定条目，可以被其他场景引用或包含在设定组中。sceneId 主要表明其初始上下文或最直接相关的场景。

### **2.2. 设定信息向量化与索引 (RAG Indexing)**

* **触发时机:**  
  * 当用户创建或更新 NovelSettingItem 条目时。  
  * 当 NovelSettingItem 条目之间的关系发生变化时（可能需要更新相关 Chunk 的元数据或重新索引）。  
  * 当 NovelSettingItem 条目被添加到或从 SettingGroup 中移除时（可能需要更新相关 Chunk 的元数据）。  
* **执行者:** IndexingService (service/impl/IndexingServiceImpl.java)。  
* **流程:**  
  1. **内容提取:** 从 NovelSettingItem 实体的 content 和 attributes 中提取需要向量化的文本内容。  
  2. **切分 (Chunking):**  
     * 使用 RecursiveCharacterTextSplitter (或类似策略) 对长文本内容进行切分。  
     * **参数:**  
       * chunkSize: 300-500 tokens (需根据 Embedding 模型调整和测试)。  
       * chunkOverlap: chunkSize 的 10-20% (需根据 chunkSize 调整和测试)。  
     * 对于结构化数据，考虑将每个逻辑单元或重要字段作为单独的 Chunk。  
  3. **元数据附加:** 为每个 Chunk 附加必要的元数据，存储在 KnowledgeChunk (domain/model/KnowledgeChunk.java) 的 metadata 字段中。**必须包含:**  
     * novelId (String)  
     * novelSettingItemId (String): 原始 NovelSettingItem 实体的 ID。  
     * sceneId (String, 可选): 原始 NovelSettingItem 的 sceneId (如果存在)。  
     * settingType (String): 原始 NovelSettingItem 的类型。  
     * settingName (String, 可选): 原始 NovelSettingItem 的名称。  
     * priority (Integer): 原始 NovelSettingItem 的优先级。  
     * generatedBy (String): 原始 NovelSettingItem 的 generatedBy 字段。  
     * status (String, 可选): 原始 NovelSettingItem 的 status 字段 (如果存在)。  
     * relatedNovelSettingItemIds (List, 可选): 与此设定块直接相关的其他小说设定条目 ID 列表 (通过 relationships 获取)。  
     * groupIds (List, 可选): 此设定块所属的设定组 ID 列表。  
  4. **嵌入 (Embedding):**  
     * 使用在 RagConfig.java 中配置的、由 EmbeddingService 提供的**专用 Embedding 模型**，将每个 Chunk 转换为向量。  
  5. **存储:**  
     * 调用 VectorStore (service/vectorstore/VectorStore.java) 接口，将 Chunk 文本、向量 (如果需要外部传入) 和元数据存入 ChromaDB。  
     * **集合管理:** 考虑为每个 novelId 创建一个独立的 ChromaDB Collection，或者使用 novelId 作为元数据进行严格过滤。

### **2.3. 相关设定检索 (RAG Retrieval) \- 增强逻辑**

* **触发时机:** 当 AI 需要生成场景内容、进行剧情推演或其他需要参考设定的任务时 (e.g., 在 NovelAIServiceImpl, NovelRagAssistantImpl, 或相关 Task Executor 中)。  
* **执行者:** NovelRagAssistantImpl (service/impl/NovelRagAssistantImpl.java) 或类似 RAG 核心组件。  
* **流程:**  
  1. **上下文收集:** 收集用于检索和生成任务的上下文信息，包括：  
     * 用户输入: 场景生成指令、场景概要、当前草稿等。  
     * 当前场景的 sceneId (如果适用且可用)。  
     * 自动提取: 上文内容、章节概要等。  
  2. **关键词提取 (使用轻量级 LLM):**  
     * **新建服务/组件:** 创建一个新的服务，例如 KeywordExtractionService。  
     * **模型选择:**  
       * 配置一个**轻量级、低延迟、低成本**的 LLM (可以与主要生成模型不同)，专门用于实体提取任务。例如，某些针对特定任务微调的小模型或 API。  
       * 在 AIServiceConfig.java 或 ProviderServiceConfig.java 中添加此模型的配置。  
     * **Prompt 设计:** 设计一个专门的 Prompt，指示 LLM 从提供的上下文中提取关键的**设定实体名词** (如人名、地名、物品名、组织名、关键概念等)。  
       * 示例 Prompt: "从以下文本中提取所有可能与小说设定相关的实体名词 (人物、地点、物品、组织、概念等)，以 JSON 列表形式返回: \[上下文文本\]"  
     * **调用 LLM:** KeywordExtractionService 调用配置好的轻量级 LLM，传入设计的 Prompt 和收集到的上下文文本。  
     * **结果解析:** 解析 LLM 返回的实体名词列表 (可能需要处理 JSON 解析和错误)。  
     * **输入:** 上下文文本。  
     * **输出:** 提取出的关键词列表 (e.g., \["艾岚", "风语城", "生命之泉", "暗影议会"\])。  
     * **成本与延迟考量:** 需要监控此步骤的成本和对整体生成流程的延迟影响。如果 LLM 调用成本过高或延迟过大，需要考虑备选方案（如缓存、更简单的提取逻辑、或使用更高效的模型）。  
  3. **查询向量生成:**  
     * 将收集到的**上下文文本** (与送入关键词提取 LLM 的文本可以相同或略有不同，侧重于语义) 使用**与索引时相同的 Embedding 模型**生成查询向量。  
  4. **获取当前激活的设定组 (Active Setting Groups):**  
     * 查询当前 novelId 下标记为 isActiveContext \== true 的 SettingGroup，获取其包含的 novelSettingItemIds。  
  5. **向量搜索与过滤 (多阶段或加权):**  
     * 调用 VectorStore.findRelevant 方法。  
     * **查询向量:** 使用步骤 3 生成的查询向量。  
     * **元数据过滤 (where 条件):**  
       * **必须:** novelId 等于当前小说的 ID。  
       * **可选 (基于 LLM 提取结果):** 使用提取的关键词列表，构建过滤条件。  
       * **可选 (基于当前场景 sceneId):** 如果上下文中包含当前场景的 sceneId，可以优先或加强与此 sceneId 关联的设定的检索权重，或作为过滤条件之一。  
       * **可选 (基于优先级预过滤):** 在某些特定场景下，可以添加对 priority 的过滤。  
       * **可选 (基于 generatedBy 和 status):** 例如，优先检索 generatedBy \= "USER" 或 status \= "ACCEPTED" 的设定。  
     * **topK 参数:** 返回一个比最终所需数量稍多的结果 (例如，初步检索 15-20 条)。  
  6. **结果处理、关系扩展与优先级/分组重排序:**  
     * 获取初步的 SearchResult 列表 (包含 KnowledgeChunk 及其元数据)。  
     * (可选) 去重。  
     * **关系扩展 (Relationship Expansion):**  
       * 对于初步检索到的每个高相关性设定 (KnowledgeChunk)，检查其 metadata.relatedNovelSettingItemIds。  
       * 如果这些关联的设定尚未在初步结果中，并且被认为是重要的，则可以考虑将其内容也加入到最终结果集。此步骤需要小心处理，避免信息过载。  
     * **重排序 (Re-ranking):**  
       * 设计一个更复杂的评分函数，综合考虑：  
         * semantic\_score: 原始向量搜索的语义相似度。  
         * priority\_score: 从 metadata.priority 计算的得分。  
         * group\_boost\_score: 如果设定块属于当前激活的 SettingGroup (metadata.groupIds 包含激活组ID)，则给予加分。  
         * scene\_relevance\_score: 如果设定块的 metadata.sceneId 与当前上下文的 sceneId 匹配，则给予加分。  
         * source\_quality\_score: 根据 metadata.generatedBy 和 metadata.status 给予不同权重 (例如，用户创建 \> AI接受 \> AI建议)。  
         * relationship\_score (可选): 如果通过关系扩展引入的设定，可以给予一定的分数。  
       * **策略示例:** final\_score \= (semantic\_score \* W\_s) \+ (priority\_score \* W\_p) \+ (group\_boost\_score \* W\_g) \+ (scene\_relevance\_score \* W\_scene) \+ (source\_quality\_score \* W\_source) \+ (relationship\_score \* W\_r)。权重因子可配置。  
       * 目标是语义相关、高优先级、属于当前激活设定组、与当前场景相关、来源可信、且紧密关联的设定排在最前面。  
     * 选择重排序后的 topN (例如 5-7 条) 结果。  
     * 格式化检索到的设定文本块，准备注入最终的生成 Prompt。

### **2.4. API 接口需求**

需要定义以下 API 端点:

* **小说设定条目管理 API (NovelSettingItemController):**  
  * POST /api/novels/{novelId}/setting-items: 创建新的小说设定条目 (请求体包含 priority, 可选 sceneId, relationships, generatedBy, status)。  
  * GET /api/novels/{novelId}/setting-items: 获取指定小说的设定条目列表 (支持分页和按 sceneId, priority 等过滤)。  
  * GET /api/setting-items/{settingItemId}: 获取单个小说设定条目的详细信息。  
  * PUT /api/setting-items/{settingItemId}: 更新单个小说设定条目。  
  * DELETE /api/setting-items/{settingItemId}: 删除单个小说设定条目。  
  * POST /api/setting-items/{settingItemId}/relationships: 为小说设定条目添加关系。  
  * PUT /api/setting-items/{settingItemId}/relationships/{relatedSettingItemId}: 修改关系。  
  * DELETE /api/setting-items/{settingItemId}/relationships/{relatedSettingItemId}: 删除关系。  
* **设定组管理 API (SettingGroupController):**  
  * POST /api/novels/{novelId}/setting-groups: 创建新的设定组。  
  * GET /api/novels/{novelId}/setting-groups: 获取指定小说的设定组列表。  
  * GET /api/setting-groups/{groupId}: 获取单个设定组的详细信息。  
  * PUT /api/setting-groups/{groupId}: 更新设定组信息 (名称、描述、激活状态)。  
  * DELETE /api/setting-groups/{groupId}: 删除设定组。  
  * POST /api/setting-groups/{groupId}/setting-items: 向设定组中添加小说设定条目。  
  * DELETE /api/setting-groups/{groupId}/setting-items/{settingItemId}: 从设定组中移除小说设定条目。  
* **设定检索 API (内部调用为主):**  
  * (内部调用) NovelRagAssistant.findRelevantSettings(novelId, contextText, currentSceneId, activeGroupIds, topK): 内部服务方法，执行完整的检索流程。  
  * (可选，用于调试) POST /api/novels/{novelId}/setting-items/retrieve-enhanced: 提供上下文、可选当前场景ID和可选的激活组ID，检索相关设定。

## **3\. 非功能需求**

* **性能:**  
  * 设定信息的索引过程应尽可能异步执行，避免阻塞用户操作。  
  * 设定检索过程（特别是 LLM 关键词提取和关系扩展）的延迟应控制在可接受范围内，避免显著影响 AI 生成内容的响应时间。需要进行性能测试和优化。  
  * 数据库查询（MongoDB 和 ChromaDB）应高效，并建立适当的索引。  
* **成本:**  
  * 监控并优化 Embedding 模型和用于关键词提取的轻量级 LLM 的 API 调用成本。  
* **可扩展性:**  
  * 架构应能支持未来更多类型的设定和更复杂的检索逻辑。  
  * 向量数据库和索引服务应能处理不断增长的设定数据量。  
* **错误处理:**  
  * 对 LLM 调用失败、向量数据库操作异常等情况进行妥善处理和日志记录。  
  * 向用户或调用方返回明确的错误信息。  
* **可配置性:**  
  * Chunking 参数 (chunkSize, chunkOverlap)、Embedding 模型、轻量级关键词提取 LLM、topK 等应可通过配置文件 (application.yml) 进行调整。  
  * 新增：优先级重排序的权重因子 (如 W\_s, W\_p, W\_g, W\_scene, W\_source, W\_r)、关系扩展的深度或规则、设定组加权的权重因子等应可配置。

## **4\. 依赖与集成**

* **前端:** 需要前端提供设定管理界面（包括关系和分组管理），并在调用 AI 生成功能时传递必要的上下文信息、当前场景ID和当前激活的设定组信息。  
* **AI 服务:** 依赖配置好的 Embedding 模型和轻量级 LLM 服务。  
* **数据库:** 依赖 MongoDB 和 ChromaDB 的正常运行。  
* **现有模块:** 与 NovelService, SceneService, EmbeddingService, VectorStore, AIService 等现有服务紧密集成。